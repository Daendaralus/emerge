
<!DOCTYPE html>
<meta charset="utf-8">

<head>
    <!-- bootstrap css v5.2.3 -->
    <link rel="stylesheet" type="text/css" href="vendors/bootstrap/css/bootstrap.css">

    <link rel="stylesheet" type="text/css" href="resources/css/custom.css" />

    <!-- dark-mode-switch css -->
    <link rel="stylesheet" href="vendors/dark-mode-switch/css/dark-mode.css">

    <!-- jquery js -->
    <script type="text/javascript" src="vendors/jquery/jquery-3.6.0.min.js"></script>
    <!-- popperjs/core v2.11.6 -->
    <script type="text/javascript" src="vendors/popper/popper.min.js"></script>
    <!-- bootstrap js v5.2.3 -->
    <script type="text/javascript" src="vendors/bootstrap/js/bootstrap.min.js"></script>

    <!-- daterange picker | https://github.com/dangrossman/daterangepicker -->
    <script type="text/javascript" src="vendors/daterangepicker/moment.min.js"></script>
    <script type="text/javascript" src="vendors/daterangepicker/daterangepicker.min.js"></script>
    <link rel="stylesheet" type="text/css" href="vendors/daterangepicker/daterangepicker.css"/>

    <!-- d3 js -->
    <script src="vendors/d3/d3.v7.8.4.min.js"></script>

    <!-- Hull.js -->
    <script type="text/javascript" src="vendors/hull/hull.js"></script>
    <!-- simpleheat.hs -->
    <script type="text/javascript" src="vendors/simpleheat/simpleheat.js"></script>
    <!-- exported graph representations as js -->
    <script type="text/javascript" src="resources/js/graph_representations_d3_force_graph.js"></script>

    <style>
        div.graphDiv {
            width: 100%;
        }

        body {
            overflow-y: hidden;
            overflow-x: hidden;
        }

        .card-body {
            padding-top: 4px;
            padding-bottom: 12px;
        }
        
        .tooltip-inner {
            background-color: white;
            color: black;
            font-size: smaller;
            text-align: left;
        }

        .wide-tooltip .tooltip-inner {
            min-width: 340px;
        }
        
        .bs-tooltip-bottom {
            margin-top: 6px;
        }

        hr {
            margin-top: 1rem;
            margin-bottom: 1rem;
            border: 0;
            border-top: 2px solid #0d6efd;
        }

        .btn {
            padding: 2px;
        }

        .btn-left-aligned {
            text-align: left !important;
            padding-left: 10px;
        }

        .btn-right-aligned {
            text-align: right !important;
            padding-right: 10px;
        }

        #projectNameListElement {
            padding-bottom: 1px;
            padding-top: 2px;
        }

        #analysisNameListElement {
            padding-bottom: 1px;
            padding-top: 1px;
        }

        #analysisDateTimeListElement {
            padding-top: 1px;
            padding-bottom: 4px;
        }

        #graphDiv {
            position: relative;
        }
        
        #inputNodeSearchLabel,
        #selectNodesLabel,
        #resetSelectionLabel,
        #expandSelectionLabel,
        #hoverSelectionLabel,
        #fadeUnselectedNodesLabel {
            font-size: 10px;
            margin-bottom: 2px;
            padding-top: 4px;
        }
        
        #cardMenu {
            position: absolute;
            top: 6px;
            right: 5px;
            width: 200px;
        }
        
        #menuButtonGroup {
            padding-left: 0px;
            padding-top: 6px;
            padding-bottom: 0px;
        }
        
        #dropdown-apply-metric {
            min-width: 200px;
        }

        .list-group {
            --bs-list-group-color: #212529;
            --bs-list-group-bg: #fff;
            --bs-list-group-border-color: rgba(0, 0, 0, 0.125);
            --bs-list-group-border-width: 1px;
            --bs-list-group-border-radius: 0.375rem;
            --bs-list-group-item-padding-x: 0.2rem;
            --bs-list-group-item-padding-y: 0.2rem;
            --bs-list-group-action-color: #495057;
            --bs-list-group-action-hover-color: #495057;
            --bs-list-group-action-hover-bg: #f8f9fa;
            --bs-list-group-action-active-color: #212529;
            --bs-list-group-action-active-bg: #e9ecef;
            --bs-list-group-disabled-color: #6c757d;
            --bs-list-group-disabled-bg: #fff;
            --bs-list-group-active-color: #fff;
            --bs-list-group-active-bg: #0d6efd;
            --bs-list-group-active-border-color: #0d6efd;
            display: flex;
            flex-direction: column;
            padding-left: 0;
            margin-bottom: 0;
            border-radius: var(--bs-list-group-border-radius);
        }

    </style>
</head>

<body>
    <div id="graphDiv"></div>

    <div id="cardMenu" class="card border-dark">
        <h6 class="card-header align-items-center text-center">
            <span aria-hidden="true">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-bounding-box-circles" viewBox="0 0 16 16">
                    <path d="M2 1a1 1 0 1 0 0 2 1 1 0 0 0 0-2zM0 2a2 2 0 0 1 3.937-.5h8.126A2 2 0 1 1 14.5 3.937v8.126a2 2 0 1 1-2.437 2.437H3.937A2 2 0 1 1 1.5 12.063V3.937A2 2 0 0 1 0 2zm2.5 1.937v8.126c.703.18 1.256.734 1.437 1.437h8.126a2.004 2.004 0 0 1 1.437-1.437V3.937A2.004 2.004 0 0 1 12.063 2.5H3.937A2.004 2.004 0 0 1 2.5 3.937zM14 1a1 1 0 1 0 0 2 1 1 0 0 0 0-2zM2 13a1 1 0 1 0 0 2 1 1 0 0 0 0-2zm12 0a1 1 0 1 0 0 2 1 1 0 0 0 0-2z"/>
                </svg>                
                <span>
                    <small> <strong><span id="configEmergeVersion" style="padding-left: 2px;"></span></strong></small>
                </span>
            </span>
        </h6>

        <div class="card-body">
            <ul class="list-group list-group-flush">
                <li class="list-group-item small d-flex justify-content-between align-items-center py-1">
                
                    <div class="form-check form-switch float-right"> 
                        <input type="checkbox" class="form-check-input" id="darkSwitch">
                        <label class="form-check-label" for="darkSwitch"><small>Dark Mode</small></label>
                    </div>

                </li>

                <li class="list-group-item small d-flex justify-content-between align-items-center medium-tooltip">
                    <small><span id="projectInfo">Project info</span></small> <span id="badge_project_info" data-bs-toggle="tooltip" data-bs-placement="bottom" data-bs-html="true" class="badge rounded-pill text-bg-primary"> ?</span></span>
                </li>

                <li class="list-group-item small d-flex justify-content-between align-items-center">
                    <small><span id="graphProperties">Graph properties</span></small> <span id="badge_graph_info" data-bs-toggle="tooltip" data-bs-placement="bottom" data-bs-html="true" class="badge rounded-pill text-bg-primary"> ?</span></span>
                </li>


<!-- 
                <li id="projectNameListElement" class="list-group-item small d-flex justify-content-between align-items-center">
                    <small><span id="configProjectName">project</span></small>
                </li>

                <li id="analysisNameListElement" class="list-group-item small d-flex justify-content-between align-items-center">
                    <small><span id="analysisName"></span></small>
                </li>

                <li id="analysisDateTimeListElement" class="list-group-item small d-flex justify-content-between align-items-center">
                    <small><span id="configAnalysisDateTime">bar</span></small>
                </li>

                <li class="list-group-item small d-flex justify-content-between align-items-center disabled py-1">
                    <small>Graph properties</small>
                </li> -->


                <!-- <li class="list-group-item small d-flex justify-content-between align-items-center py-1">
                    <small>Nodes</small>
                    <span class="badge badge-primary badge-pill" id="numberNodes">0</span>
                </li>
                <li class="list-group-item small d-flex justify-content-between align-items-center py-1">
                    <small>Edges</small>
                    <span class="badge badge-primary badge-pill" id="numberEdges">0</span>
                </li>
                <li class="list-group-item small d-flex justify-content-between align-items-center py-1">
                    <small>Charge force</small>
                    <span class="badge badge-primary badge-pill" id="chargeForce">0</span>
                </li> -->


            </ul>

            <div id="menuButtonGroup" class="btn-group-vertical" style="min-width: 80px;">
                <div class="btn-group">
                     
                    <button type="button" class="btn btn-primary btn-sm dropdown-toggle btn-with-spacing shadow-none" id="selectGraphButton" data-bs-toggle="dropdown">
                        <span id="selectedGraph">selected graph</span>
                    </button>

                    <div class="dropdown-menu" id="dropdown-graph" aria-labelledby="dropdown-graph">
                        <!-- injected by JS -->
                    </div>

                </div>

                <button type="button" class="btn-left-aligned btn btn-primary btn-sm btn-with-spacing shadow-none" onclick="toggleNodeLabels();">
                <span aria-hidden="true">
                    <svg width="16px" height="16px" viewBox="0 0 18 18" class="bi bi-info-circle" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                        <path fill-rule="evenodd" d="M8 15A7 7 0 1 0 8 1a7 7 0 0 0 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>
                        <path d="M8.93 6.588l-2.29.287-.082.38.45.083c.294.07.352.176.288.469l-.738 3.468c-.194.897.105 1.319.808 1.319.545 0 1.178-.252 1.465-.598l.088-.416c-.2.176-.492.246-.686.246-.275 0-.375-.193-.304-.533L8.93 6.588z"/>
                        <circle cx="8" cy="4.5" r="1"/>
                    </svg>
                </span>
                Toggle node labels
            </button>

                <div class="btn-group" role="group" aria-label="Basic example">
                    <button type="button" class="btn-left-aligned btn btn-primary btn-sm btn-with-spacing btn-with-spacing-right shadow-none" onclick="decreaseCurrentChargeForce();">
                    <span aria-hidden="true">
                        <svg width="16px" height="16px" viewBox="0 0 18 18" class="bi bi-minus-circle" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                            <path fill-rule="evenodd" d="M8 15A7 7 0 1 0 8 1a7 7 0 0 0 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>
                            <path fill-rule="evenodd" d="M5.5 8a.5.5 0 0 1 .5-.5h4a.5.5 0 0 1 0 1H6a.5.5 0 0 1-.5-.5z"/>
                        </svg>
                    </span>
                    force
                </button>
                    <button type="button" class="btn-right-aligned btn btn-primary btn-sm btn-with-spacing btn-with-spacing-left shadow-none" onclick="increaseCurrentChargeForce();">
                    <span aria-hidden="true">
                        <svg width="16px" height="16px" viewBox="0 0 18 18" class="bi bi-plus-circle" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                            <path fill-rule="evenodd" d="M8 15A7 7 0 1 0 8 1a7 7 0 0 0 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>
                            <path fill-rule="evenodd" d="M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z"/>
                        </svg>
                    </span>
                    force
                </button>
                </div>

                <div class="btn-group" role="group" aria-label="Basic example">
                    <button type="button" class="btn-left-aligned btn btn-primary btn-sm btn-with-spacing btn-with-spacing-right shadow-none" onclick="zoomOut();">
                        <span aria-hidden="true">
                            <svg width="16px" height="16px" viewBox="0 0 18 18" class="bi bi-zoom-out" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                                <path fill-rule="evenodd" d="M6.5 12a5.5 5.5 0 1 0 0-11 5.5 5.5 0 0 0 0 11zM13 6.5a6.5 6.5 0 1 1-13 0 6.5 6.5 0 0 1 13 0z"/>
                                <path d="M10.344 11.742c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1 6.538 6.538 0 0 1-1.398 1.4z"/>
                                <path fill-rule="evenodd" d="M3 6.5a.5.5 0 0 1 .5-.5h6a.5.5 0 0 1 0 1h-6a.5.5 0 0 1-.5-.5z"/>
                            </svg>
                        </span>
                        zoom
                    </button>

                    <button type="button" class="btn-right-aligned btn btn-primary btn-sm btn-with-spacing btn-with-spacing-left shadow-none" onclick="zoomIn();">
                    <span aria-hidden="true">
                    <svg width="16px" height="16px" viewBox="0 0 18 18" class="bi bi-zoom-in" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                        <path fill-rule="evenodd" d="M6.5 12a5.5 5.5 0 1 0 0-11 5.5 5.5 0 0 0 0 11zM13 6.5a6.5 6.5 0 1 1-13 0 6.5 6.5 0 0 1 13 0z"/>
                        <path d="M10.344 11.742c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1 6.538 6.538 0 0 1-1.398 1.4z"/>
                        <path fill-rule="evenodd" d="M6.5 3a.5.5 0 0 1 .5.5V6h2.5a.5.5 0 0 1 0 1H7v2.5a.5.5 0 0 1-1 0V7H3.5a.5.5 0 0 1 0-1H6V3.5a.5.5 0 0 1 .5-.5z"/>
                    </svg>
                    </span>
                    zoom
                    </button>
                </div>

                <button type="button" class="btn btn-primary btn-sm btn-with-spacing shadow-none" onclick="translateCanvas('up')">
                <span aria-hidden="true">
                    <svg width="16px" height="16px" viewBox="0 0 18 18" class="bi bi-arrow-up-circle" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                        <path fill-rule="evenodd" d="M8 15A7 7 0 1 0 8 1a7 7 0 0 0 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>
                        <path fill-rule="evenodd" d="M8 12a.5.5 0 0 0 .5-.5V5.707l2.146 2.147a.5.5 0 0 0 .708-.708l-3-3a.5.5 0 0 0-.708 0l-3 3a.5.5 0 1 0 .708.708L7.5 5.707V11.5a.5.5 0 0 0 .5.5z"/>
                    </svg>
                </span>
            </button>
                <div class="btn-group" role="group" aria-label="Basic example">
                    <button type="button" class="btn btn-primary btn-sm btn-with-spacing btn-with-spacing-right shadow-none" onclick="translateCanvas('left')">
                    <span aria-hidden="true">
                        <svg width="16px" height="16px" viewBox="0 0 18 18" class="bi bi-arrow-left-circle" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                            <path fill-rule="evenodd" d="M8 15A7 7 0 1 0 8 1a7 7 0 0 0 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>
                            <path fill-rule="evenodd" d="M12 8a.5.5 0 0 1-.5.5H5.707l2.147 2.146a.5.5 0 0 1-.708.708l-3-3a.5.5 0 0 1 0-.708l3-3a.5.5 0 1 1 .708.708L5.707 7.5H11.5a.5.5 0 0 1 .5.5z"/>
                        </svg>
                    </span>
                </button>
                    <button type="button" class="btn btn-primary btn-sm btn-with-spacing btn-with-spacing-left  shadow-none" onclick="translateCanvas('right')">
                    <span aria-hidden="true">
                        <svg width="16px" height="16px" viewBox="0 0 18 18" class="bi bi-arrow-right-circle" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                            <path fill-rule="evenodd" d="M8 15A7 7 0 1 0 8 1a7 7 0 0 0 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>
                            <path fill-rule="evenodd" d="M4 8a.5.5 0 0 0 .5.5h5.793l-2.147 2.146a.5.5 0 0 0 .708.708l3-3a.5.5 0 0 0 0-.708l-3-3a.5.5 0 1 0-.708.708L10.293 7.5H4.5A.5.5 0 0 0 4 8z"/>
                        </svg>
                    </span>
                </button>
                </div>
                <button type="button" class="btn btn-primary btn-sm btn-with-spacing shadow-none" onclick="translateCanvas('down')">
                <span aria-hidden="true">
                    <svg width="16px" height="16px" viewBox="0 0 18 18" class="bi bi-arrow-down-circle" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                        <path fill-rule="evenodd" d="M8 15A7 7 0 1 0 8 1a7 7 0 0 0 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>
                        <path fill-rule="evenodd" d="M8 4a.5.5 0 0 1 .5.5v5.793l2.146-2.147a.5.5 0 0 1 .708.708l-3 3a.5.5 0 0 1-.708 0l-3-3a.5.5 0 1 1 .708-.708L7.5 10.293V4.5A.5.5 0 0 1 8 4z"/>
                    </svg>
                </span>
            </button>
                <button id="buttonShowOverallStatistics" type="button" class="btn-left-aligned btn btn-primary btn-sm btn-with-spacing shadow-none" data-bs-toggle="modal" data-bs-target="#overallStatisticsModal">
                <span aria-hidden="true">
                    <svg width="16px" height="16px" viewBox="0 0 18 18" class="bi bi-graph-up" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                        <path fill-rule="evenodd" d="M0 0h1v15h15v1H0V0zm10 3.5a.5.5 0 0 1 .5-.5h4a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-1 0V4.9l-3.613 4.417a.5.5 0 0 1-.74.037L7.06 6.767l-3.656 5.027a.5.5 0 0 1-.808-.588l4-5.5a.5.5 0 0 1 .758-.06l2.609 2.61L13.445 4H10.5a.5.5 0 0 1-.5-.5z"/>
                    </svg>
                </span>
                Overall statistics
            </button>
                <!-- Modal -->
                <div class="modal fade" id="overallStatisticsModal" tabindex="-1" role="dialog" aria-labelledby="overallStatisticsModalLabel" aria-hidden="true">
                    <div class="modal-dialog" role="document">
                        <div class="modal-content">
                            <div class="modal-header">
                                <h5 class="modal-title" id="overallStatisticsModalLabel">Overall statistics</h5>
                                <button type="button" class="close" data-bs-dismiss="modal" aria-label="Close">
                            <span aria-hidden="true">&times;</span>
                            </button>
                            </div>
                            <div class="modal-body">
                                <table class="card-table table table-condensed">
                                    <thead class="table-borderless">
                                        <tr>
                                            <th scope="col">Statistic</th>
                                            <th scope="col">Value</th>
                                        </tr>
                                    </thead>
                                    <tbody id="tbody-statistics">
                                        <!-- injected by js -->
                                    </tbody>
                                </table>
                            </div>
                            <div class="modal-footer">
                                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                            </div>
                        </div>
                    </div>
                </div>
                <!-- end modal -->

                <button type="button" id="buttonShowOverallMetrics" class="btn-left-aligned btn btn-primary btn-sm btn-with-spacing shadow-none" data-bs-toggle="modal" data-bs-target="#overallMetricsModal">
                    <span aria-hidden="true">
                        <svg width="16px" height="16px" viewBox="0 0 18 18" class="bi bi-graph-up" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                            <path fill-rule="evenodd" d="M0 0h1v15h15v1H0V0zm10 3.5a.5.5 0 0 1 .5-.5h4a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-1 0V4.9l-3.613 4.417a.5.5 0 0 1-.74.037L7.06 6.767l-3.656 5.027a.5.5 0 0 1-.808-.588l4-5.5a.5.5 0 0 1 .758-.06l2.609 2.61L13.445 4H10.5a.5.5 0 0 1-.5-.5z"/>
                        </svg>
                    </span>
                    Overall metrics
                </button>

                <div class="btn-group">
                    <button type="button" class="btn btn-primary btn-sm dropdown-toggle btn-with-spacing" data-bs-toggle="dropdown"><span></span> <span class="caret"></span>Apply metrics</button>
                    <ul id="dropdown-apply-metric" class="dropdown-menu">
                        <!-- injected by js -->
                    </ul>
                </div>

                <div style="width: 100%; padding-top: 4px; padding-bottom: 0px;"></div>

                <ul class="list-group list-group-flush">

                <!-- Shortcuts -->
                <li class="list-group-item small d-flex justify-content-between align-items-center" style="border: 0px; margin-bottom: 0px; padding-left: 0px;">
                      <label style="margin-bottom: 0px; padding-right: 4px;"> <small>Shortcuts</small> </label> <span id="badge_shortcuts" data-bs-toggle="tooltip" data-bs-placement="bottom" data-bs-html="true" class="badge rounded-pill text-bg-primary" customClass="large-tooltip"> ?</span>
                </li>

                <li id="li-unselected-opacity" class="list-group-item small d-flex justify-content-between align-items-center py-1" style="border: 0px; margin-bottom: 0px; padding-left: 0px; padding-bottom: 0px;">
                    <small>Unselected opacity</small> <span id="badge_unselected_opacity" style="margin-left: 4px;" data-bs-toggle="tooltip" data-bs-placement="bottom" data-bs-html="true" class="badge rounded-pill text-bg-primary"> ?</span>
                </li>
                <input type="range" min="1" max="100" value="20" class="form-range" id="unselected-opacity" oninput="unselectedOpacityChange(this.value)" onchange="unselectedOpacityChange(this.value)">

                <!-- Git settings -->
                <div style="width: 100%; padding-top: 4px; padding-bottom: 0px;"></div>
                <li class="list-group-item small d-flex justify-content-between align-items-center py-1 disabled" style="max-height: 24px; border: 0px; margin-bottom: 0px; padding-left: 0px;">
                    <small style="font-size: 10px;">Git settings </small>
                    <div class="form-group" style="width: 50%;">
                        <hr>
                    </div>
                </li>

                <div class="input-group mb-1 input-group-sm">
                <input class="form-control form-control-sm" type="text" name="daterange" placeholder="pick date range" id="timeDateRangePicker" style="font-size: 9px;" />
                <button class="btn btn-primary " type="button" id="inputDateRangePickerCancel" onclick="clickDateRangePickerCancel()">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-bootstrap-reboot" viewBox="0 0 16 16">
                        <path d="M1.161 8a6.84 6.84 0 1 0 6.842-6.84.58.58 0 1 1 0-1.16 8 8 0 1 1-6.556 3.412l-.663-.577a.58.58 0 0 1 .227-.997l2.52-.69a.58.58 0 0 1 .728.633l-.332 2.592a.58.58 0 0 1-.956.364l-.643-.56A6.812 6.812 0 0 0 1.16 8z"/>
                        <path d="M6.641 11.671V8.843h1.57l1.498 2.828h1.314L9.377 8.665c.897-.3 1.427-1.106 1.427-2.1 0-1.37-.943-2.246-2.456-2.246H5.5v7.352h1.141zm0-3.75V5.277h1.57c.881 0 1.416.499 1.416 1.32 0 .84-.504 1.324-1.386 1.324h-1.6z"/>
                      </svg>
                </button>
                </div>
            
                <div style="width: 100%; padding-top: 6px; padding-bottom: 0px;"></div>

                <!-- time series modal -->
                <!-- Modal -->
                <div class="modal fade" id="timeSeriesModal" tabindex="-1" aria-labelledby="timeSeriesModalLabel" aria-hidden="true">
                    <div class="modal-dialog modal-xl">
                    <div class="modal-content">
                        <div class="modal-header">
                        <h1 class="modal-title fs-5" id="timeSeriesModalLabel">Modal title</h1>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                        </div>
                        <div class="modal-body">
                        
                        <div id="my_dataviz_chord"></div>
                        <br>
                        
                        <div id="my_dataviz"></div>
                        <br>
                        <div id="my_dataviz2"></div>

                        </div>
                        <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                        <button type="button" class="btn btn-primary">Save changes</button>
                        </div>
                    </div>
                    </div>
                </div>

                <button type="button" class="btn-left-aligned btn btn-primary btn-sm btn-with-spacing shadow-none" data-bs-toggle="modal" data-bs-target="#timeSeriesModal" onclick="generateTimeSeriesChart()" >
                    <span aria-hidden="true">
                        <svg width="16px" height="16px" viewBox="0 0 18 18" class="bi bi-graph-up" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                            <path fill-rule="evenodd" d="M0 0h1v15h15v1H0V0zm10 3.5a.5.5 0 0 1 .5-.5h4a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-1 0V4.9l-3.613 4.417a.5.5 0 0 1-.74.037L7.06 6.767l-3.656 5.027a.5.5 0 0 1-.808-.588l4-5.5a.5.5 0 0 1 .758-.06l2.609 2.61L13.445 4H10.5a.5.5 0 0 1-.5-.5z"/>
                        </svg>
                    </span>
                    Complexity/Churn
                </button>

                <!-- time series modal -->
                <!-- Modal -->
                <div class="modal fade" id="changeCouplingModal" tabindex="-1" aria-labelledby="changeCouplingModalLabel" aria-hidden="true">
                    <div class="modal-dialog modal-xl">
                    <div class="modal-content">
                        <div class="modal-header">
                        <h1 class="modal-title fs-5" id="changeCouplingModalLabel">Change Coupling</h1>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                        </div>
                        <div class="modal-body">
                        
                        <div id="change_coupling_chord_diagram"></div>

                        </div>
                        <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                        <button type="button" class="btn btn-primary">Save changes</button>
                        </div>
                    </div>
                    </div>
                </div>

                <button type="button" class="btn-left-aligned btn btn-primary btn-sm btn-with-spacing shadow-none" data-bs-toggle="modal" data-bs-target="#changeCouplingModal" onclick="generateChangeCouplingChart()" >
                    <span aria-hidden="true">
                        <svg width="16px" height="16px" viewBox="0 0 18 18" class="bi bi-graph-up" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                            <path fill-rule="evenodd" d="M0 0h1v15h15v1H0V0zm10 3.5a.5.5 0 0 1 .5-.5h4a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-1 0V4.9l-3.613 4.417a.5.5 0 0 1-.74.037L7.06 6.767l-3.656 5.027a.5.5 0 0 1-.808-.588l4-5.5a.5.5 0 0 1 .758-.06l2.609 2.61L13.445 4H10.5a.5.5 0 0 1-.5-.5z"/>
                        </svg>
                    </span>
                    Change Coupling
                </button>

                <!--
                <button type="button" class="btn-left-aligned btn btn-primary btn-sm btn-with-spacing shadow-none" data-bs-toggle="modal" data-bs-target="#timeSeriesModal" onclick="generateTimeSeriesChart()" >
                    <span aria-hidden="true">
                        <svg width="16px" height="16px" viewBox="0 0 18 18" class="bi bi-graph-up" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                            <path fill-rule="evenodd" d="M0 0h1v15h15v1H0V0zm10 3.5a.5.5 0 0 1 .5-.5h4a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-1 0V4.9l-3.613 4.417a.5.5 0 0 1-.74.037L7.06 6.767l-3.656 5.027a.5.5 0 0 1-.808-.588l4-5.5a.5.5 0 0 1 .758-.06l2.609 2.61L13.445 4H10.5a.5.5 0 0 1-.5-.5z"/>
                        </svg>
                    </span>
                    Hotspot scatterplot
                </button>

                <button type="button" class="btn-left-aligned btn btn-primary btn-sm btn-with-spacing pl-0 shadow-none text-left" data-bs-toggle="modal" data-bs-target="#timeSeriesModal" onclick="generateTimeSeriesChart()" >
                    <span aria-hidden="true">
                        <svg width="16px" height="16px" viewBox="0 0 18 18" class="bi bi-graph-up" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                            <path fill-rule="evenodd" d="M0 0h1v15h15v1H0V0zm10 3.5a.5.5 0 0 1 .5-.5h4a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-1 0V4.9l-3.613 4.417a.5.5 0 0 1-.74.037L7.06 6.767l-3.656 5.027a.5.5 0 0 1-.808-.588l4-5.5a.5.5 0 0 1 .758-.06l2.609 2.61L13.445 4H10.5a.5.5 0 0 1-.5-.5z"/>
                        </svg>
                    </span>
                    Complexity growth
                </button> -->

                <div style="width: 100%; padding-top: 2px; padding-bottom: 0px;"></div>

               
                <!-- <div class="form-check form-switch small float-right"> 
                    <input type="checkbox" class="form-check-input" id="switchTemporalEdges">
                    <label class="form-check-label d-flex justify-content-between" for="switchTemporalEdges"><small>Temporal edges </small> <span id="badge_add_temporal_edges" data-bs-toggle="tooltip" data-bs-placement="bottom" data-bs-html="true" class="badge rounded-pill text-bg-primary"> ?</span> </label>
                </div>

                <div class="form-check form-switch small float-right"> 
                    <input type="checkbox" class="form-check-input" id="switchHighlightTemporalEdges">
                    <label class="form-check-label d-flex justify-content-between" for="switchHighlightTemporalEdges"><small>Highlight temp </small> <span id="badge_highlight_teporal_edges" data-bs-toggle="tooltip" data-bs-placement="bottom" data-bs-html="true" class="badge rounded-pill text-bg-primary"> ?</span> </label>
                </div> -->

                <div style="width: 100%; padding-top: 6px; padding-bottom: 0px;"></div>

                <li class="list-group-item small d-flex justify-content-between align-items-center disabled" style="max-height: 24px; border: 0px; margin-bottom: 0px; padding-left: 0px;">
                    <small style="font-size: 10px;">Heatmap settings </small>
                    <div class="form-group" style="width: 38%; padding: 0px;">
                        <hr>
                    </div>
                </li>
                
                <div class="form-check form-switch small float-right"> 
                    <input type="checkbox" class="form-check-input" id="switchActivateHeatmap">
                    <label class="form-check-label d-flex justify-content-between" for="switchActivateHeatmap"><small>Normal Heatmap </small> <span id="badge_heat_map_normal" data-bs-toggle="tooltip" data-bs-placement="bottom" data-bs-html="true" class="badge rounded-pill text-bg-primary"> ?</span> </label>
                </div>

                <div class="form-check form-switch small float-right"> 
                    <input type="checkbox" class="form-check-input" id="switchMergeHeatmap">
                    <label class="form-check-label d-flex justify-content-between" for="switchMergeHeatmap"><small>Hybrid Heatmap</small> <span id="badge_heat_map_hybrid" data-bs-toggle="tooltip" data-bs-placement="bottom" data-bs-html="true" class="badge rounded-pill text-bg-primary"> ?</span> </label>
                </div>

                <div id="formSwitchChurnHeatmap" class="form-check form-switch small float-right"> 
                    <input type="checkbox" class="form-check-input" id="switchChurnHeatmap">
                    <label class="form-check-label d-flex justify-content-between" for="switchChurnHeatmap"><small>Churn Heatmap </small> <span id="badge_heat_map_churn" data-bs-toggle="tooltip" data-bs-placement="bottom" data-bs-html="true" class="badge rounded-pill text-bg-primary"> ?</span> </label>
                </div>

                <div id="formSwitchHotspotHeatmap" class="form-check form-switch small float-right"> 
                    <input type="checkbox" class="form-check-input" id="switchHotspotHeatmap">
                    <label class="form-check-label d-flex justify-content-between" for="switchHotspotHeatmap"><small>Hotspot Heatmap </small> <span id="badge_heat_map_hotspot" data-bs-toggle="tooltip" data-bs-placement="bottom" data-bs-html="true" class="badge rounded-pill text-bg-primary"> ?</span> </label>
                </div>

                <div style="width: 100%; padding-top: 6px; padding-bottom: 0px;"></div>

                <label id="inputNodeSearchLabel" for="inputNodeSearch">0 nodes found</label>
                
                <div class="input-group mb-1 input-group-sm">
                    <input id="inputNodeSearch" type="text" class="form-control" placeholder="Search nodes" aria-label="Search" aria-describedby="search-addon">
                    <button class="btn btn-primary " type="button" id="inputNodeSearchCancel">
                        <svg width="16px" height="16px" viewBox="0 0 18 18" class="bi bi-graph-up" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                            <path d="M14 1a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h12zM2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2z"/>
                            <path d="M4.646 4.646a.5.5 0 0 1 .708 0L8 7.293l2.646-2.647a.5.5 0 0 1 .708.708L8.707 8l2.647 2.646a.5.5 0 0 1-.708.708L8 8.707l-2.646 2.647a.5.5 0 0 1-.708-.708L7.293 8 4.646 5.354a.5.5 0 0 1 0-.708z"/>
                        </svg>
                    </button>

                    <div style="width: 100%; padding-top: 8px; padding-bottom: 0px;"></div>
                    <div class="form-check form-switch small float-right" style="width: 100%;"> 
                        <input type="checkbox" class="form-check-input" id="switchAddSemanticSearch">
                        <label class="form-check-label d-flex justify-content-between" for="switchAddSemanticSearch"><small>Add semantics</small> <span id="badge_semantic_search" data-bs-toggle="tooltip" data-bs-placement="bottom" data-bs-html="true" class="badge rounded-pill text-bg-primary"> ?</span> </label>
                    </div>

                    <div class="form-check form-switch small float-right" style="width: 100%;"> 
                        <input type="checkbox" class="form-check-input" id="switchAddContributorSearch">
                        <label class="form-check-label d-flex justify-content-between" for="switchAddContributorsSearch"><small>Add contributors</small> <span id="badge_contributors_search" data-bs-toggle="tooltip" data-bs-placement="bottom" data-bs-html="true" class="badge rounded-pill text-bg-primary"> ?</span> </label>
                    </div>

                    <!-- <div class="form-check form-switch small float-right" style="width: 100%;"> 
                        <input type="checkbox" class="form-check-input" id="switchMainContributorsSearch">
                        <label class="form-check-label d-flex justify-content-between" for="switchMainContributorsSearch"><small>Main contributors</small> <span id="badge_main_contributors_search" data-bs-toggle="tooltip" data-bs-placement="bottom" data-bs-html="true" class="badge rounded-pill text-bg-primary"> ?</span> </label>
                    </div> -->

                </div>
                
                <li class="list-group-item small d-flex justify-content-between align-items-center" style="padding-left: 0px; padding-right: 1px;" >
                    <label style="margin-bottom: 0px; font-size: 10px;"> Hover/select cluster hulls </label> <span id="badge_cluster_hulls" data-bs-toggle="tooltip" data-bs-placement="bottom" data-bs-html="true" class="badge rounded-pill text-bg-primary" customClass="large-tooltip"> ?</span>
                </li>

                <div id="clusterHullMenu">
                <!-- cluster hull selection / injected by javascript -->
                </div>

                </ul>

            </div>

            <!-- Modal -->
            <div class="modal fade" id="overallMetricsModal" tabindex="-1" role="dialog" aria-labelledby="overallMetricsModalLabel" aria-hidden="true">
                <div class="modal-dialog" role="document">
                    <div class="modal-content">

                        <div class="modal-header">
                            <h1 class="modal-title fs-5" id="exampleModalLabel">Overall metrics</h1>
                            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                        </div>

                        <div class="modal-body">
                            <table class="card-table table table-condensed">
                                <thead class="table-borderless">
                                    <tr>
                                        <th scope="col">Metric</th>
                                        <th scope="col">Value</th>
                                    </tr>
                                </thead>
                                <tbody id="tbody-metrics">
                                    <!-- injected by js -->
                                </tbody>
                            </table>
                        </div>

                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                        </div>

                    </div>
                </div>
            </div>
            <!-- end modal -->

            <div class="toast-container position-fixed top-0 start-0 p-3">
            <div id="toastDateRangeUpdated" class="toast align-items-center" role="alert" aria-live="assertive" aria-atomic="true" data-bs-delay="3500">
                <div class="d-flex">
                  <div class="toast-body small">
                    Git date range updated, metrics, visualizations and graph structures may have changed.
                  </div>
                  <button type="button" class="btn-close me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
                </div>
              </div>
            </div>

            <div class="toast-container position-fixed top-0 start-0 p-3">
                <div id="toastDebug" class="toast align-items-center" role="alert" aria-live="assertive" aria-atomic="true" data-bs-delay="2000">
                    <div class="d-flex">
                        <div id="toastDebugMessage" class="toast-body small">
                            text
                        </div>
                        <button type="button" class="btn-close me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
                    </div>
                </div>
            </div>

        </div>

        <script src="vendors/dark-mode-switch/js/dark-mode-switch.min.js"></script>

    </div>

    <script>
        // Some JS code is derived/borrowed or heavily inspired from demos/examples by the following people:
        // Mike Bostock - https://github.com/mbostock, https://bost.ocks.org/mike/
        // Tom Roth - https://bl.ocks.org/puzzler10/4438752bb93f45dc5ad5214efaa12e4a
        // Ma'moun othman/@mamounothman - https://stackoverflow.com/questions/61800343/d3-js-version-5-chart-to-pdf
        // Sam Leach/@SamuelLeach - https://gist.github.com/samuelleach/5497403
        // Pranav C Balan - https://stackoverflow.com/questions/41287778/get-all-possible-object-keys-from-a-list-of-objects-javascript-typescript
        // If I missed someone or gave wrong credit, please contact me and I'll update this.

        const activeNodeLabelColor = hexToRGB("#333333", 0.6)
        const passiveNodeLabelColor = hexToRGB("#333333", 0.2)
        const dmActiveNodeLabelColor = hexToRGB("#DDDDDD", 0.6)
        const dmPassiveNodeLabelColor = hexToRGB("#DDDDDD", 0.2)

        const activeEdgeColor = hexToRGB("#AAAAAA", 1.0);
        const passiveEdgeColor = hexToRGB("#AAAAAA", 0.2);
        const dmActiveEdgeColor = hexToRGB("#888888", 0.8)
        const dmPassiveEdgeColor = hexToRGB("#888888", 0.2)

        const toolTipMetricItemTextColor = hexToRGB("#333333", 0.7);
        const toolTipMetricItemBoxColor = hexToRGB("#333333", 1.0);
        const toolTipMetricItemBoxFillColor = hexToRGB("#f7f7f7", 1.0);

        const activeSelectionColor = '#FF0000'
        const directoryNodeColor = '#3b8cff'
        const fileNodeColor = '#d1e3ff'
        const defaultNodeColor = '#1f77b4'
        const semanticHeaderYellow = '#f5bc42'
        const contributorsPurple = '#ff00ff'

        /**
         * * MARK: - Math constants
         */
        const TWO_TIMES_PI = 2 * Math.PI
        const ONE_THIRD_TWO_TIMES_PI = (1.0 / 3.0) * TWO_TIMES_PI

        /**
         * * MARK: - UI workarounds
         */
        // workaround from https://stackoverflow.com/questions/6985507/one-time-page-refresh-after-first-page-load to fix strange safari full screen loading problems
        let userAgent = navigator.userAgent.toLowerCase();
        if (userAgent.includes('safari')) {
            window.onload = function() {
                if (!window.location.hash) {
                    window.location = window.location + '#loaded';
                    window.location.reload();
                }
            }
        }

        // Workaround to prevent buttons that trigger modals to stay focused after dismiss (https://stackoverflow.com/questions/30322918/bootstrap-modal-restores-button-focus-on-close)
        $('body').on('hidden.bs.modal', '.modal', function() {
            $('#buttonShowOverallMetrics').blur();
            $('#buttonShowOverallStatistics').blur();
        });

        // cancel the node search by pressing the escape key
        $(document).keyup(function(e) {
            if (e.key === "Escape") {
                cancelNodeSearch()
            }
        });

        function setDarkMode(mode) {
            if (mode == true) {
                darkMode = true
                currentActiveNodeLabelColor = dmActiveNodeLabelColor
                currentPassiveNodeLabelColor = dmPassiveNodeLabelColor
                currentActiveEdgeColor = dmActiveEdgeColor
                currentPassiveEdgeColor = dmPassiveEdgeColor
                simulationUpdate()
            } else {
                darkMode = false
                currentActiveNodeLabelColor = activeNodeLabelColor
                currentPassiveNodeLabelColor = passiveNodeLabelColor
                currentActiveEdgeColor = activeEdgeColor
                currentPassiveEdgeColor = passiveEdgeColor
                simulationUpdate()
            }
        }

        const tooltipTriggerList = document.querySelectorAll('[data-bs-toggle="tooltip"]')
        const tooltipList = [...tooltipTriggerList].map(tooltipTriggerEl => new bootstrap.Tooltip(tooltipTriggerEl))

        /**
         * * MARK: - Metric info badge tooltip descriptions
         */
        const description_metric_sloc_in_file = '"Source lines of code (SLOC), also known as lines of code (LOC), is a software metric used to measure the size of a computer program by counting the number of lines in the text of the programs source code. SLOC is typically used to predict the amount of effort that will be required to develop a program, as well as to estimate programming productivity or maintainability once the software is produced." (Wikipedia)'
        const description_metric_number_of_methods = 'A metric representing the total number of methods found per file or entity. This is similar to a weighted methods per class (WMC) metric with a uniform complexity/weight of 1.'
        const description_metric_fan_in = '"Fan-in coupling (afferent coupling) the number of entities that depend on a given entity. It estimates in what extent the "external world" depends on the changes in a given entity" (gcc.gnu.org). This metric represents the number of dependencies FROM other files or entities.'
        const description_metric_fan_out = '"Fan-out coupling (efferent coupling) the number of entities the given entity depends upon. It estimates in what extent the given entity depends on the changes in "external world" (gcc.gnu.org). This metric represents the number of dependencies TO other files or entities.'
        const description_metric_louvain_modularity = '"The Louvain method for community detection is a method to extract communities from large networks" (Wikipedia). This metric seperates detected communities by a unique number/ node size.'
        const description_heat_map_normal = '"A heat map (or <strong>heatmap</strong>) is a data visualization technique that shows magnitude of a phenomenon as color in two dimensions" (Wikipedia). The heatmap score is based on a weighted score from the fan-out and SLOC metric. Red color indicates a warning (hotspot), that given metric scores may be to high, while decreasing into blue color.'
        const description_heat_map_hybrid = 'This is a visual (hybrid) <strong>combination</strong> of the normal graph visualization and a heatmap layer behind it'
        const description_unselected_opacity = 'Set the opacity for all unselected nodes after selecting a few with <br><br><strong>shift + s</strong><br><br> and fading all others with <br><br><strong>shift + f</strong>'

        const description_semantic_search = 'Enrich the search results by including semantic keywords (computed by <strong>tf-idf</strong>) which try to describe the content of a node more exactly'
        const description_cluster_hulls = 'Hover over a cluster node color to get a highlighted preview of the concave hull of the appropriate cluster and display basic cluster statistics via tooltip. In addition to that you can also mark/select multiple cluster hulls that will then render permanently.'

        const wide_tooltip_template =
        `
        '<div class="tooltip wide-tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>'
        `

        const description_shortcuts_tooltip =
            `
            <b>shift + s</b> 👉 (de)select hovered nodes
            <br>

            <b>shift + r</b> 👉 resets selected nodes
            <br>
        
            <b>shift + e</b> 👉 selects all nodes linked to selected nodes
            <br>
        
            <b>shift + h</b> 👉 selects all nodes linked to hovered node
            <br>
        
            <b>shift + f</b> 👉 fade unselected nodes</span>
            `
        let description_project_info = ""
        let description_graph_info = ""

        let heatmapMerged = false
        let heatmapActive = false
        let heatmapChurn = false
        let heatmapHotspot = false

        let addTemporalEdges = false

        let selectedNodesMap = {}
        var unselectedNodesOpacity = 0.20
        let fadeUnselectedNodes = false
        let currentActiveNodeLabelColor = activeNodeLabelColor
        let currentPassiveNodeLabelColor = passiveNodeLabelColor

        let currentActiveEdgeColor = activeEdgeColor
        let currentPassiveEdgeColor = passiveEdgeColor

        let dateRangePickerFrom = ""
        let dateRangePickerTo = ""

        let commit_dates = commit_metrics.map(x => x.date);
        let commit_first_date = commit_dates[0]
        let commit_last_date = commit_dates[commit_dates.length - 1]

        let includeGitMetrics = false
        let gitMetricsIndexFrom = 0
        let gitMetricsIndexTo = 0

        dateRangePickerFrom = commit_first_date
        dateRangePickerTo = commit_last_date
        
        const nodeStrokeStyle = "#333333";

        let darkMode = false
        let isSearching = false
        let addSemanticSearch = false
        let addContributorSearch = false

        let searchString = ""

        let searchTerms = []
        let searchResults = 0

        const radius = 7;
        const height = window.innerHeight * 2;
        const graphWidth = window.innerWidth * 2;

        const maxClusterHulls = 20
        let selectedClusterHullIds = []
        let hoveredClusterHullId = undefined

        let nodeLabelsEnabled = false

        let currentTranslation = {
            horizontal: 0,
            vertical: 0,
            lastDirection: ""
        }

        let fileResultPrefix = commit_metrics[0].file_result_prefix // TODO: pass/extract as/from extra common git metrics dict
        let fileResultPrefixFull = commit_metrics[0].file_result_prefix_full

        let activeMetrics
        let currentMetricKeys

        let currentGraphType
        let closeNode;

        // daterangepicker for git date range
        function initDateRangeUI() {
            $('input[name="daterange"]').daterangepicker({
                "startDate": commit_first_date,
                "endDate": commit_last_date,
                "minDate": commit_first_date,
                "maxDate": commit_last_date,

                isInvalidDate: function(date) {
                    if ( commit_dates.includes(date.format('DD/MM/YYYY')) ) {
                        return false
                    } else {
                        return true
                    }
                },

                "locale": {
                    "format": "DD/MM/YYYY",
                    "separator": " - ",
                    "applyLabel": "Apply",
                    "cancelLabel": "Cancel",
                    "fromLabel": "From",
                    "toLabel": "To",
                    "customRangeLabel": "Custom",
                    "weekLabel": "W",
                    "daysOfWeek": [
                        "Su",
                        "Mo",
                        "Tu",
                        "We",
                        "Th",
                        "Fr",
                        "Sa"
                    ],
                    "monthNames": [
                        "January",
                        "February",
                        "March",
                        "April",
                        "May",
                        "June",
                        "July",
                        "August",
                        "September",
                        "October",
                        "November",
                        "December"
                    ],
                    "firstDay": 1
                },

                opens: 'left'
            }, function(start, end, label) {
                console.log("A new date selection was made: " + start.format('DD/MM/YYYY') + ' to ' + end.format('DD/MM/YYYY'));
                dateRangePickerFrom = start.format('DD/MM/YYYY')
                dateRangePickerTo = end.format('DD/MM/YYYY')

                // console.log(dateRangePickerFrom)
                // console.log(dateRangePickerTo)
                
                initGitMetricsForDateRange()
                showToastDateRangeUpdate()
            })
        }

        function showToastDateRangeUpdate() {
            const toastLiveExample = document.getElementById('toastDateRangeUpdated')
            const toast = new bootstrap.Toast(toastLiveExample)    
            toast.show()
        }

        function showDebugToast(message) {
            const toastDebug = document.getElementById('toastDebug')
            const toast = new bootstrap.Toast(toastDebug)
            const div = document.querySelector("#toastDebugMessage");
            div.innerHTML = message;
            toast.show()
        }

        function clickDateRangePickerCancel() {
            console.log("reset date range picker")
            initDateRangeUI()
            dateRangePickerFrom = commit_first_date
            dateRangePickerTo = commit_last_date
            initGitMetricsForDateRange()
            showToastDateRangeUpdate()
        }

        function initGitMetricsForDateRange() {
            gitMetricsIndexFrom = commit_dates.indexOf( dateRangePickerFrom );
            gitMetricsIndexTo = commit_dates.lastIndexOf( dateRangePickerTo );
            // console.log("found first index: " + gitMetricsIndexFrom + " for `from` " + dateRangePickerFrom)
            // console.log("found last index: " + gitMetricsIndexTo + " for `to` " + dateRangePickerTo)
            addGitMetricToFileNodes()
        }

        function calculateFileChurnForDateRange() {
            let totalFileChurnDict = {}

            for (let i = gitMetricsIndexFrom; i < gitMetricsIndexTo; i++) {
                let nextChurnDict = commit_metrics[i].churn
                totalFileChurnDict = mergeDicts(totalFileChurnDict, nextChurnDict)
            }

            return totalFileChurnDict
        }

        function calculateWhiteSpaceComplexityForDateRange() {
            let totalWhiteSpaceComplexityDict = {}

            for (let i = gitMetricsIndexFrom; i < gitMetricsIndexTo; i++) {
                let nextWhiteSpaceComplexityDict = commit_metrics[i].ws_complexity
                totalWhiteSpaceComplexityDict = mergeDicts(totalWhiteSpaceComplexityDict, nextWhiteSpaceComplexityDict)
            }

            return totalWhiteSpaceComplexityDict
        }

        function calculateAuthorsForDateRange() {
            let totalFileAuthorsDict = {}

            for (let i = gitMetricsIndexFrom; i < gitMetricsIndexTo; i++) {
                let nextFileAuthorsDict = commit_metrics[i].files_author_map
                totalFileAuthorsDict = mergeDicts(totalFileAuthorsDict, nextFileAuthorsDict)
            }
            return totalFileAuthorsDict
        }

        function addGitMetricToFileNodes() {
            if (currentGraphType.includes('file_result_dependency_graph')) {

                let fileChurnMap = calculateFileChurnForDateRange()
                let whiteSpaceComplexityMap = calculateWhiteSpaceComplexityForDateRange()
                let authorsMap = calculateAuthorsForDateRange()
                // console.log(authorsMap)

                currentGraph.nodes.forEach(function(node, i) {

                    // housekeeping git code churn
                    delete node['metric_git_code_churn']
                    if (node.hasOwnProperty('metrics')) {
                        delete node.metrics['metric_git_code_churn']
                    }

                    // housekeeping git ws complexity
                    delete node['metric_git_ws_complexity']
                    if (node.hasOwnProperty('metrics')) {
                        delete node.metrics['metric_git_ws_complexity']
                    }

                    // housekeeping git number of file authors
                    delete node['metric_git_number_authors']
                    if (node.hasOwnProperty('metrics')) {
                        delete node.metrics['metric_git_number_authors']
                    }
                    delete node['metric_git_main_contrib']
                    if (node.hasOwnProperty('metrics')) {
                        delete node.metrics['metric_git_main_contrib']
                    }

                    // housekeeping file contributors
                    delete node['metric_git_contributors']
                    if (node.hasOwnProperty('metrics')) {
                        delete node.metrics['metric_git_contributors']
                    }

                    if (!node.hasOwnProperty('metrics')) {
                        node.metrics = {}
                    }

                    let nodeFileName = node.id.split("/").pop();
                    let nodeSearchPath = fileResultPrefix + "/" + node.id

                    // add git code churn
                    if (nodeSearchPath in fileChurnMap) {
                        node['metric_git_code_churn'] = fileChurnMap[nodeSearchPath]
                        node.metrics['metric_git_code_churn'] = fileChurnMap[nodeSearchPath]
                    }

                    // add git whitespace complexity
                    if (nodeSearchPath in whiteSpaceComplexityMap) {
                        node['metric_git_ws_complexity'] = whiteSpaceComplexityMap[nodeSearchPath]
                        node.metrics['metric_git_ws_complexity'] = whiteSpaceComplexityMap[nodeSearchPath]
                    }

                    // add git number authors
                    if (nodeSearchPath in authorsMap) {
                        let main_contributor = mainContributor(authorsMap[nodeSearchPath])
                        node['metric_git_number_authors'] = Object.keys(authorsMap[nodeSearchPath]).length //result[1].length
                        node.metrics['metric_git_number_authors'] = Object.keys(authorsMap[nodeSearchPath]).length //result[1].length
                        node['metric_git_main_contrib'] = main_contributor
                        node.metrics['metric_git_main_contrib'] = main_contributor
                    }

                    // add all git contributors to file
                    if (nodeSearchPath in authorsMap) {
                        node['metric_git_contributors'] = Object.keys(authorsMap[nodeSearchPath])
                        node.metrics['metric_git_contributors'] = Object.keys(authorsMap[nodeSearchPath])
                    }

                });
            }
        }

        function mainContributor(obj={}, asc=true) { 
            let biggestChurn = 0
            let authorBiggestChurn = ''
            
            for (let key in obj) {
                if (obj[key] > biggestChurn) {
                    biggestChurn = obj[key]
                    authorBiggestChurn = key
                }
            }
            
            return authorBiggestChurn
        }

        // based on https://copyprogramming.com/howto/javascript-dictionary-merge-best-methods-to-combine-key-value-pairs?utm_content=cmp-true
        function mergeDicts(dict1, dict2) {
            const result = {};
            
            for (const key in dict1) {    
                if (dict2.hasOwnProperty(key)) {
                    if ( Array.isArray(dict1[key]) && Array.isArray(dict2[key]) ) {
                        result[key] = dict1[key].concat(dict2[key])
                    } else if ( typeof dict1[key] === "object" && typeof dict2[key] === "object") {
                        result[key] = Object.assign({}, dict1[key], dict2[key]);
                    } else {
                        result[key] = dict1[key] + dict2[key];
                    }
                } else {
                    result[key] = dict1[key];
                }
            }
            
            for (const key in dict2) {
                if (!dict1.hasOwnProperty(key)) {
                    result[key] = dict2[key];
                }
            }
            return result;
        }

        function setDirection(direction) {
            currentTranslation.lastDirection = direction
        }

        function toggleNodeLabels() {
            nodeLabelsEnabled = !nodeLabelsEnabled
            simulationUpdate()
        }

        let zoom_handler = d3.zoom()
            .on("zoom", zoomed);

        let graphCanvas = d3.select('#graphDiv').append('canvas')
            .attr('width', graphWidth + 'px')
            .attr('height', height + 'px')
            .attr('id', 'mainCanvas')
            .node();

        let graphData = {}
        let currentGraph = ''

        let clusterMap = {}
        let clusterMetricsMap = {}

        let statistics
        let overall_metric_results

        initAppConfig()
        initHeatmapSwitches()

        initAddTemporalSwitch()
        initSemanticSearchSwitch()
        initContributorSearchSwitch()

        setInitialDarkMode()
        prepareGraphStructures()
        initAppUI()

        let context = graphCanvas.getContext('2d');

        // nice fix from https://stackoverflow.com/questions/8696631/canvas-drawings-like-lines-are-blurry to remove blurry drawing
        graphCanvas.style.height = (height / 2) + "px";
        graphCanvas.style.width = (graphWidth / 2) + "px";
        graphCanvas.getContext('2d').scale(2, 2);

        let div = d3.select("body").append("div")
            .attr("class", "tooltip")
            .style("opacity", 0);

        let currentChargeForce = -500
        let currentLinkDistance = 20
        let simulation

        let transform = d3.zoomIdentity;

        // heatmap
        var heat = simpleheat('mainCanvas');

        // bring back d3 schemeCategory20 to live
        const schemeCategory20 = "1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5"

        function d3ColorExport(specifier) {
            let n = specifier.length / 6 | 0,
                colors = new Array(n),
                i = 0;
            while (i < n) colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
            return colors;
        }

        // important to define the domain for the ordinal scale
        const color = d3.scaleOrdinal(d3ColorExport(schemeCategory20))
            .domain([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19])

        /**
         * * MARK: - Connectivity checks 
         */
        let linkedByIndex = {};

        function isConnected(a, b) {
            return isConnectedAsTarget(a, b) || isConnectedAsSource(a, b) || a.id === b.id;
        }

        function isConnectedAsSource(a, b) {
            return linkedByIndex[`${a.id},${b.id}`];
        }

        function isConnectedAsTarget(a, b) {
            return linkedByIndex[`${b.id},${a.id}`];
        }

        function edgeBetweenSearchTerms(sourceNode, targetNode) {
            let found = false
            searchTerms.forEach(element => {
                if ( (sourceNode.id.toLowerCase().includes(element)) && (targetNode.id.toLowerCase().includes(element)) ) {
                    found = true
                }
            });
            return found
        }

        function searchTermsIncludedInNodeTags(sourceNode, targetNode) {
            let found = false
            searchTerms.forEach(element => {
                if ((stringIncludedInNodeTags(element, sourceNode) && stringIncludedInNodeTags(element, targetNode))) {
                    found = true
                }
            });
            return found
        }

        function searchTermsIncludedInNodeContributors(sourceNode, targetNode) {
            let found = false
            searchTerms.forEach(element => {
                if ((stringIncludedInNodeContributors(element, sourceNode) && stringIncludedInNodeContributors(element, targetNode))) {
                    console.log("edge found")
                    found = true
                }
            });
            return found
        }

        /**
         * * MARK: - Drawing on canvas
         */
         function drawEdges(context) {
            currentGraph.links.forEach(function(d) {

                context.beginPath();
                context.moveTo(d.source.x, d.source.y);
                context.lineTo(d.target.x, d.target.y);

                if (closeNode == null) { // not hovering over any node
                    if (isSearching == false) { // not searching                     
                        context.fillStyle = context.strokeStyle = nodeSourceColor = nodeColorByModularity(d.source, 0.7)

                    } else { // node search is active

                        if (addSemanticSearch == true) {

                            // the edge is between two nodes that are included in the search OR the edge is between two nodes that includes the search in one of their semantic keywords
                            if ( edgeBetweenSearchTerms(d.source, d.target) || searchTermsIncludedInNodeTags(d.source, d.target) )
                            { 
                                context.strokeStyle = currentActiveEdgeColor
                                context.fillStyle = currentActiveEdgeColor
                            } else { // the edge is not connected to a node which is included in the search
                                context.fillStyle = context.strokeStyle = currentPassiveEdgeColor
                            }

                        
                        }  else { // normal search without semantic
                            // the edge is between two nodes that are included in the search
                            if (edgeBetweenSearchTerms(d.source, d.target))                            
                            { 
                                context.strokeStyle = currentActiveEdgeColor
                                context.fillStyle = currentActiveEdgeColor
                            } else { // the edge is not connected to a node which is included in the search
                                context.fillStyle = context.strokeStyle = currentPassiveEdgeColor
                            }
                        }

                        if (addContributorSearch == true ) {
                            // the edge is between two nodes that are included in the search OR the edge is between two nodes that includes the search in one of their semantic keywords
                            if ( searchTermsIncludedInNodeContributors(d.source, d.target) )
                            { 
                                context.strokeStyle = currentActiveEdgeColor
                                context.fillStyle = currentActiveEdgeColor
                            }
                        }
                        
                    }

                } else {
                    if ((d.target.id == closeNode.id) || (d.source.id == closeNode.id)) { // there is an edge that contains our hovered node
                        context.strokeStyle = currentActiveEdgeColor
                        context.fillStyle = currentActiveEdgeColor

                    } else { // node is not included in the edge
                        context.fillStyle = context.strokeStyle = nodeColorByModularity(d.source, 0.2)
                    }   
                }

                // highlight edge if the corresponding nodes are selected
                if (d.source.id.toLowerCase() in selectedNodesMap && d.target.id.toLowerCase() in selectedNodesMap) {
                    context.strokeStyle = activeSelectionColor
                    context.fillStyle = currentActiveEdgeColor
                    context.lineWidth = 2.0;
                } else {
                    if (fadeUnselectedNodes == true || normalHeatmapIsActive() || churnHeatmapIsActive() || hotspotHeatmapIsActive()) { // also fade away non-relevant egdes
                        context.fillStyle = context.strokeStyle = nodeColorByModularity(d.source, unselectedNodesOpacity)
                    } 
                    context.lineWidth = 1.0;
                }

                context.stroke();

                if (closeNode != null && ((d.target.id == closeNode.id) || (d.source.id == closeNode.id))) { // draw an arrow if there is an edge that contains our hovered node
                    drawArrowhead(context, d.source, d.target, 5)

                } else if (isSearching && ( (searchTermIncludedInNode(d.target) ) && ( searchTermIncludedInNode(d.source)) )) { // draw an arrow if searching is enabled and there's an egde between searched nodes
                    drawArrowhead(context, d.source, d.target, 5)
                }
                
                else if (d.source.id.toLowerCase() in selectedNodesMap && d.target.id.toLowerCase() in selectedNodesMap) {
                    drawArrowhead(context, d.source, d.target, 5)
                }                    
                
            });
        }

        function normalSearch(node) {
            let found = false
            searchTerms.forEach(element => {
                if (node.id.toLowerCase().includes(element)) {
                    found = true
                }
            });
            return found
        }

        // the node is included in the current search OR if the search in included in one of the node's semantic tags 
        function searchTermIncludedInNode(node) {
            let found = false
                searchTerms.forEach(element => {
                    if (node.id.toLowerCase().includes(element)) {
                        found = true
                    }
                });
            return found
        }
        
        function searchTermIncludedInNodeTags(node) {
            let found = false
            searchTerms.forEach(element => {
                if ( stringIncludedInNodeTags(element, node) ) {
                    found = true
                }
            });
            return found
        }

        function searchTermIncludedInNodeContributors(node) {
            let found = false
            searchTerms.forEach(element => {
                if ( stringIncludedInNodeContributors(element, node) ) {
                    found = true
                }
            });
            return found
        }

        function drawNodes(context) {
            currentGraph.nodes.forEach(function(d, i) {

                context.beginPath();

                //render outer circle if node was selected
                if (d.id.toLowerCase() in selectedNodesMap) {

                    context.arc(d.x, d.y, d.radius + 2.0, 0, TWO_TIMES_PI);
                    context.fillStyle = '#FF0000' //activeSelectionColor
                    drawNodeLabel(d.id, d.x + 14, d.y - 7)
                    context.fill();
                }

                context.arc(d.x, d.y, d.radius, 0, TWO_TIMES_PI, true);

                if (fadeUnselectedNodes == true || normalHeatmapIsActive() || churnHeatmapIsActive() || hotspotHeatmapIsActive()) {
                    context.strokeStyle = nodeStrokeStyle
                    context.fillStyle = hexToRGB(nodeStrokeStyle, unselectedNodesOpacity)
                    context.stroke();

                    if (nodeLabelsEnabled) {
                        context.fillStyle = currentPassiveNodeLabelColor;
                        drawNodeLabel(d.id, d.x + 14, d.y - 7)
                        context.fillStyle = nodeColorByModularity(d, unselectedNodesOpacity)
                    }

                } else {

                    if (closeNode == null) { // not hovering over any node
                        if (isSearching == false) {

                            context.fillStyle = nodeColorByModularity(d)
                            context.strokeStyle = nodeStrokeStyle;
                            context.stroke();

                            if (nodeLabelsEnabled) {
                                context.fillStyle = currentActiveNodeLabelColor;
                                drawNodeLabel(d.id, d.x + 14, d.y - 7)
                                context.fillStyle = nodeColorByModularity(d)
                            }

                        } else { // searching for nodes

                            // normal (non-semantic) search
                            if ( addSemanticSearch == false && normalSearch(d)) {

                                context.fillStyle = nodeColorByModularity(d)
                                context.strokeStyle = nodeStrokeStyle;
                                context.stroke();

                                context.fillStyle = currentActiveNodeLabelColor;
                                drawNodeLabel(d.id, d.x + 14, d.y - 7)
                                context.fillStyle = nodeColorByModularity(d)

                                searchResults += 1

                            } else if ( addSemanticSearch == true && (searchTermIncludedInNode(d) || searchTermIncludedInNodeTags(d)) )
                                // add semantic search
                                // the node is included in the current search OR if the search in included in one of the node's semantic tags 
                                // draw a highlight circle behind the found node due to semantic search
                                {
                                if ( searchTermIncludedInNodeTags(d) )
                                {
                                    context.fillStyle = currentActiveNodeLabelColor;
                                    drawNodeLabel(d.id, d.x + 14, d.y - 7)
                                    
                                    drawNodeHighlight(d, nodeColorByModularity(d, 1.0))
                                    context.strokeStyle = nodeStrokeStyle;
                                    context.stroke();

                                    drawNodeHighlight(d, semanticHeaderYellow, 2)
                                    context.strokeStyle = nodeStrokeStyle;
                                    context.stroke();

                                    searchResults += 1
                                    
                                } else {

                                    context.fillStyle = nodeColorByModularity(d)
                                    context.strokeStyle = nodeStrokeStyle;
                                    context.stroke();

                                    context.fillStyle = currentActiveNodeLabelColor;
                                    drawNodeLabel(d.id, d.x + 14, d.y - 7)
                                    context.fillStyle = nodeColorByModularity(d)

                                    searchResults += 1
                                }

                            } else {
                                context.fillStyle = nodeColorByModularity(d, 0.2)
                                context.strokeStyle = hexToRGB(nodeStrokeStyle, 0.2)
                                context.stroke();

                                if (nodeLabelsEnabled) {
                                    context.fillStyle = currentPassiveNodeLabelColor;
                                    drawNodeLabel(d.id, d.x + 14, d.y - 7)
                                    context.fillStyle = nodeColorByModularity(d, 0.2)
                                }
                            }
                        }

                        // contributors search
                        if (addContributorSearch == true && searchTermIncludedInNodeContributors(d)) {

                            context.fillStyle = currentActiveNodeLabelColor;
                            drawNodeLabel(d.id, d.x + 14, d.y - 7)
                            
                            drawNodeHighlight(d, nodeColorByModularity(d, 1.0))
                            context.strokeStyle = nodeStrokeStyle;
                            context.stroke();

                            drawNodeHighlight(d, contributorsPurple, 2)
                            context.strokeStyle = nodeStrokeStyle;
                            context.stroke();

                            searchResults += 1
                        }

                    } else { // hovering over a node
                        if (isConnected(d, closeNode)) { // node is connected to hovered node
                            context.fillStyle = nodeColorByModularity(d)
                            context.strokeStyle = nodeStrokeStyle;
                            context.stroke();

                            // show/highlight node label of every connected node from the hovered node
                            context.fillStyle = currentActiveNodeLabelColor;
                            drawNodeLabel(d.id, d.x + 14, d.y - 7)
                            context.fillStyle = nodeColorByModularity(d)

                        } else { // node is not connected

                            if (d.id.toLowerCase() in selectedNodesMap) {
                                context.strokeStyle = nodeStrokeStyle
                                context.fillStyle = nodeColorByModularity(d)
                                context.stroke();
                            } else { 
                                context.strokeStyle = hexToRGB(nodeStrokeStyle, 0.2)
                                context.fillStyle = nodeColorByModularity(d, 0.2)
                                context.stroke();
                            }

                            if (nodeLabelsEnabled) {
                                context.fillStyle = currentPassiveNodeLabelColor;
                                drawNodeLabel(d.id, d.x + 14, d.y - 7)
                                context.fillStyle = nodeColorByModularity(d, 0.2)
                            }
                        }
                    }

                } // else not fade away unselected nodes

                context.fill();

                if (i == currentGraph.nodes.length - 1) { // dont call this to often due to performance

                    if (closeNode) {
                        context.beginPath();
                        drawNode(closeNode)

                        if (closeNode.id.toLowerCase() in selectedNodesMap) {
                            context.fillStyle = activeSelectionColor
                        } else {
                            context.fillStyle = nodeColorByModularity(closeNode)
                        }
                        
                        context.fill();
                        context.strokeStyle = "#000000";
                        context.lineWidth = 1.0;
                        context.stroke();

                        drawNodeToolTip(closeNode.id, closeNode.x + 14, closeNode.y - 7, closeNode.metrics)
                    }
                }
            });
        }

        /**
         * * MARK: - Drawing a heatmap for normal / hybrid (merged) mode
         */

         function calculateHeatmapScore(node) {

            let totalScore = 0

            if (normalHeatmapIsActive() || mergedHeatmapIsActive() ) {

                let score = analysis_config['heatmap']['score']['base']
                let slocScore = 0
                let fanoutScore = 0

                if (analysis_config['heatmap']['metrics']['active']['sloc'] == true) {
                    // add weighted sloc metric if present
                    if ('metric_sloc_in_entity' in node) {
                        slocScore = node.metric_sloc_in_entity * analysis_config['heatmap']['metrics']['weights']['sloc']
                    }
                    if ('metric_sloc_in_file' in node) {
                        slocScore = node.metric_sloc_in_file * analysis_config['heatmap']['metrics']['weights']['sloc']
                    }
                }

                if (analysis_config['heatmap']['metrics']['active']['fan_out'] == true) {
                    // add weighted fan-out metric is present
                    if ('metric_fan_out_dependency_graph' in node) {
                        fanoutScore = node.metric_fan_out_dependency_graph * analysis_config['heatmap']['metrics']['weights']['fan_out']
                    }
                    if ('metric_fan_out_inheritance_graph' in node) {
                        fanoutScore = node.metric_fan_out_inheritance_graph * analysis_config['heatmap']['metrics']['weights']['fan_out']
                    }
                    if ('metric_fan_out_complete_graph' in node) {
                        fanoutScore = node.metric_fan_out_complete_graph * analysis_config['heatmap']['metrics']['weights']['fan_out']
                    }
                }

                // limit the total score to the heatmap limit parameter, since the rendering seems to be buggy if this is exceeded
                totalScore = score + slocScore + fanoutScore
                if (totalScore > analysis_config['heatmap']['score']['limit']) {
                    totalScore = analysis_config['heatmap']['score']['limit']
                }

            } else if (churnHeatmapIsActive()) {
                let score = analysis_config['churn_heatmap']['score']['base']
                let churnScore = 0
                
                if (node.hasOwnProperty('metric_git_code_churn')) {
                    if (analysis_config['churn_heatmap']['metrics']['active']['churn'] == true) {
                        churnScore = node.metric_git_code_churn * analysis_config['churn_heatmap']['metrics']['weights']['churn']
                    }
                    
                    totalScore = score + churnScore
                    if (totalScore > analysis_config['churn_heatmap']['score']['limit']) {
                        totalScore = analysis_config['churn_heatmap']['score']['limit']
                    }      
                }

            } else if (hotspotHeatmapIsActive()) {
                // approach: let's define a hotspot as a product of the following factors
                // 1. code churn over a given time period
                // 2. whitespace complexity over a given time period
                // 3. connectivity based on dependencies inside the network (i.e. fan-in / fan-out)

                let score = analysis_config['hotspot_heatmap']['score']['base']
                let churnScore = 0
                let ws_complexity_score = 0
                let connectivity_score = 0

                if (node.hasOwnProperty('metric_git_code_churn') && node.hasOwnProperty('metric_git_ws_complexity') ) {
                    if (analysis_config['hotspot_heatmap']['metrics']['active']['churn'] == true && analysis_config['hotspot_heatmap']['metrics']['active']['ws_complexity'] == true) {
                        churnScore = node.metric_git_code_churn * analysis_config['hotspot_heatmap']['metrics']['weights']['churn']
                        ws_complexity_score = node.metric_git_code_churn * analysis_config['hotspot_heatmap']['metrics']['weights']['ws_complexity'] * 0.75

                        if ('metric_fan_out_dependency_graph' in node) {
                            connectivity_score = node.metric_fan_out_dependency_graph * 10.0
                        }

                        totalScore = (churnScore + ws_complexity_score + connectivity_score)
                        if (totalScore > analysis_config['hotspot_heatmap']['score']['limit'] * 1.25  ) {
                            totalScore = analysis_config['hotspot_heatmap']['score']['limit'] * 1.25
                        }
                    }
                }

            }

            return totalScore
        }

        function drawHeatMap(context) {

            if (normalHeatmapIsActive() || mergedHeatmapIsActive()) {
                heat.max(analysis_config['heatmap']['score']['limit']);
            }

            if (churnHeatmapIsActive()) {
                heat.max(analysis_config['churn_heatmap']['score']['limit']);
            }

            if (hotspotHeatmapIsActive()) {
                heat.max(analysis_config['hotspot_heatmap']['score']['limit']);
            }

            heat.clear();
            currentGraph.nodes.forEach(function(node, i) {
                heat.add([node.x, node.y, calculateHeatmapScore(node)])
            })

            heat.draw()
            
            // reset alpha from heatmap rendering
            context.globalAlpha = 1;  
        }


        function drawLink(d) {
            context.moveTo(d.source.x, d.source.y);
            context.lineTo(d.target.x, d.target.y);
        }

        function drawNode(d) {
            context.arc(d.x, d.y, d.radius, 0, TWO_TIMES_PI);
        }

        function drawNodeHighlight(node, color, radiusOffset) {
            context.arc(node.x, node.y, node.radius + radiusOffset, 0, TWO_TIMES_PI);
            context.fillStyle = color
            context.strokeStyle = color;
            context.stroke();
            context.fill();
        }

        function drawNodeLabel(text, xPos, yPos) {
            const fontSize = 8
            context.font = fontSize + 'px Helvetica';
            context.fillText(text, xPos, yPos);
        }

        function stringIncludedInNodeTags(string, node) {
            let propertyNames = Object.getOwnPropertyNames(node.metrics)
            let searchedTag = 'metric_tag_' + string
            let found = false

            let tagProperties = propertyNames.filter(function(property) {
                return property.startsWith('metric_tag_')
            })

            tagProperties.forEach(function(propertyName) {
                if (propertyName.toLowerCase().includes(string.toLowerCase())) {
                    found = true
                }
            })
       
            return found
        }

        function stringIncludedInNodeContributors(string, node) {
            let found = false
            if (node.hasOwnProperty('metrics')) {
                let metrics = node['metrics']
                if ('metric_git_contributors' in metrics) {
                    const contributors = metrics['metric_git_contributors']
                    contributors.forEach(function(name) {
                        if (name.toLowerCase().includes(string.toLowerCase())) {
                            found = true
                        }
                    })
                }
            }
            
            return found
        }

        function drawNodeToolTip(text, xPos, yPos, nodeMetrics) {

            // $('#overallStatisticsModal').modal('show');

            const fontSize = 14
            context.font = fontSize + 'px Helvetica';

            // determine the maximum label width
            let maxLineWidth = 0
            for (metricKey in nodeMetrics) {
                const val = nodeMetrics[metricKey]
                let human_readable_metric_name = metricKey.replace('metric_', '').replace(/_/gi, " ")
                const w = context.measureText(human_readable_metric_name + ": " + val).width;
                if (maxLineWidth < w) {
                    maxLineWidth = w
                }
            }

            // check if actually the title line width if bigger than any metric label line width?
            const nodeTitleLineWidth = context.measureText(text).width
            if (nodeTitleLineWidth > maxLineWidth)
                maxLineWidth = nodeTitleLineWidth

            // draw the header/title of the toolip    
            let lineHeight = fontSize * 1.286;
            context.fillStyle = hexToRGB("#0069d9", 1.0);
            context.fillRect(xPos - 6, (yPos - lineHeight) + 2, maxLineWidth + 10, lineHeight + 4);
            context.strokeStyle = hexToRGB("#333333", 1.0);
            context.strokeRect(xPos - 6, (yPos - lineHeight) + 2, maxLineWidth + 10, lineHeight + 4)

            context.fillStyle = hexToRGB("#FFFFFF", 0.8);
            context.fillText(text, xPos, yPos);

            // now draw the second tooltip box with all metric labels
            let metricItem = 1
            const metricFontSize = 14
            const metricLineHeight = (metricFontSize * 1.286);
            let yPosOffset = yPos + 10
            let newYPos = 0
            let renderWithTags = false

            context.font = metricFontSize + 'px Helvetica';

            for (metricKey in nodeMetrics) {
                
                // do not include any tag/tfidf metric in the primary metric section
                if (metricKey.includes('metric_tag')) {
                    renderWithTags = true
                    continue
                }

                let val = nodeMetrics[metricKey]
                let human_readable_metric_name = metricKey.replace('metric_', '').replace(/_/gi, " ")
                let metricItemText = human_readable_metric_name + ": " + val

                newYPos = yPosOffset + (metricLineHeight * metricItem)

                // Interesting bug: on Safari it seems to cause random lags if you do fillStyle/fillRect BEFORE strokeStyle/strokeRect
                context.strokeStyle = toolTipMetricItemBoxColor
                context.strokeRect(xPos - 6, (newYPos - metricLineHeight), maxLineWidth + 10, metricLineHeight)

                context.fillStyle = toolTipMetricItemBoxFillColor
                context.fillRect(xPos - 6, (newYPos - metricLineHeight), maxLineWidth + 10, metricLineHeight);

                context.fillStyle = toolTipMetricItemTextColor;
                context.fillText(metricItemText, xPos, newYPos - 4);

                metricItem = metricItem + 1
            }

            // render tag/tfidf metric section
            if (renderWithTags) {
                let metricItem = 1
                newYPos += 20
                
                // draw the header/title of the toolip    
                context.fillStyle = hexToRGB("#f5bc42", 1.0);
                context.fillRect(xPos - 6, (newYPos - lineHeight) + 2, maxLineWidth + 10, lineHeight + 4);
                context.strokeStyle = hexToRGB("#333333", 1.0);
                context.strokeRect(xPos - 6, (newYPos - lineHeight) + 2, maxLineWidth + 10, lineHeight + 4)
                context.fillStyle = hexToRGB("#333333", 0.8);
                context.fillText('Semantic keywords', xPos, newYPos);

                let yTagPosOffset = newYPos + 10

                // render tag/tfidf metrics
                for (metricKey in nodeMetrics) {
                    
                    // do not include any tag/tfidf metric in the primary metric section
                    if (!metricKey.includes('metric_tag')) {
                        continue
                    }

                    let val = nodeMetrics[metricKey]
                    let human_readable_metric_name = metricKey.replace('metric_tag', '').replace(/_/gi, "")
                    let metricItemText = human_readable_metric_name // + ": " + val

                    newYPos = yTagPosOffset + (metricLineHeight * metricItem)

                    // Interesting bug: on Safari it seems to cause random lags if you do fillStyle/fillRect BEFORE strokeStyle/strokeRect
                    context.strokeStyle = toolTipMetricItemBoxColor
                    context.strokeRect(xPos - 6, (newYPos - metricLineHeight), maxLineWidth + 10, metricLineHeight)

                    context.fillStyle = toolTipMetricItemBoxFillColor
                    context.fillRect(xPos - 6, (newYPos - metricLineHeight), maxLineWidth + 10, metricLineHeight);

                    context.fillStyle = toolTipMetricItemTextColor;
                    context.fillText(metricItemText, xPos, newYPos - 4);

                    metricItem = metricItem + 1
                }
            }
        }

        // borrowed from Scott Johnson / https://gist.github.com/jwir3/d797037d2e1bf78a9b04838d73436197 with minor adjustments
        function drawArrowhead(context, from, to, radius) {
            const x_center = 0.5 * (from.x + to.x)
            const y_center = 0.5 * (from.y + to.y)

            let angle;
            let x;
            let y;

            context.beginPath();

            angle = Math.atan2(to.y - from.y, to.x - from.x)
            x = radius * Math.cos(angle) + x_center;
            y = radius * Math.sin(angle) + y_center;

            context.moveTo(x, y);

            angle += ONE_THIRD_TWO_TIMES_PI
            x = radius * Math.cos(angle) + x_center;
            y = radius * Math.sin(angle) + y_center;

            context.lineTo(x, y);

            angle += ONE_THIRD_TWO_TIMES_PI
            x = radius * Math.cos(angle) + x_center;
            y = radius * Math.sin(angle) + y_center;

            context.lineTo(x, y);
            context.closePath();
            context.fill();
        }

        function nodeColorByModularity(node, alpha = 1.0) {
            if (currentGraphType.includes('file_result') || currentGraphType.includes('filesystem')) {
                if ('metric_file_result_dependency_graph_louvain_modularity_in_file' in node) {
                    return hexToRGB(color(node.metric_file_result_dependency_graph_louvain_modularity_in_file), alpha)
                } else if ('directory' in node) {
                    if (node.directory == true) {
                        return hexToRGB(directoryNodeColor)
                    }
                }
            } else {
                if (currentGraphType.includes('entity_result_dependency_graph')) {
                    if ('metric_entity_result_dependency_graph_louvain_modularity_in_entity' in node) {
                        return hexToRGB(color(node.metric_entity_result_dependency_graph_louvain_modularity_in_entity), alpha)
                    }
                }
                if (currentGraphType.includes('entity_result_inheritance_graph')) {
                    if ('metric_entity_result_inheritance_graph_louvain_modularity_in_entity' in node) {
                        return hexToRGB(color(node.metric_entity_result_inheritance_graph_louvain_modularity_in_entity), alpha)
                    }
                }
                
                if (currentGraphType.includes('entity_result_complete_graph')) {
                    if ('metric_entity_result_complete_graph_louvain_modularity_in_entity' in node) {
                        return hexToRGB(color(node.metric_entity_result_complete_graph_louvain_modularity_in_entity), alpha)
                    }
                }
            }

            return hexToRGB(defaultNodeColor) 
        }

        function initModals() {
            const modal = document.getElementById('timeSeriesModal')
            modal.addEventListener('hidden.bs.modal', event => {
                d3.select("#timeSeriesComplexityChart").remove();
                d3.select("#timeSeriesChurnChart").remove();
            })

            const chordModal = document.getElementById('changeCouplingModal')
            chordModal.addEventListener('hidden.bs.modal', event => {
                d3.select("#svg_change_coupling_chord_diagram").remove();
            })
        }

        function setInitialDarkMode() {
            if (document.body.getAttribute("data-theme") == "dark") {
                currentActiveNodeLabelColor = dmActiveNodeLabelColor
                currentPassiveNodeLabelColor = dmPassiveNodeLabelColor
                currentActiveEdgeColor = dmActiveEdgeColor
                currentPassiveEdgeColor = dmPassiveEdgeColor
                darkMode = true
            } else {
                currentActiveNodeLabelColor = activeNodeLabelColor
                currentPassiveNodeLabelColor = passiveNodeLabelColor
                currentActiveEdgeColor = activeEdgeColor
                currentPassiveEdgeColor = passiveEdgeColor
                darkMode = false
            }
        }

        /**
         * * MARK: - Rendering concave hulls of clusters.
         */
        function setupGraphClustersById() {
            clusterMap = {}
            currentGraph.nodes.forEach(function(node, i) {
                let nodeClusterId = 0

                if (node.hasOwnProperty('metric_file_result_dependency_graph_louvain_modularity_in_file')) {
                    nodeClusterId = node.metric_file_result_dependency_graph_louvain_modularity_in_file
                } else if (node.hasOwnProperty('metric_entity_result_dependency_graph_louvain_modularity_in_entity')) {
                    nodeClusterId = node.metric_entity_result_dependency_graph_louvain_modularity_in_entity
                } else if (node.hasOwnProperty('metric_entity_result_inheritance_graph_louvain_modularity_in_entity')) {
                    nodeClusterId = node.metric_entity_result_inheritance_graph_louvain_modularity_in_entity
                } else if (node.hasOwnProperty('metric_entity_result_complete_graph_louvain_modularity_in_entity')) {
                    nodeClusterId = node.metric_entity_result_complete_graph_louvain_modularity_in_entity
                }

                nodeClusterId = nodeClusterId.toString()

                if (nodeClusterId in clusterMap) {
                    clusterMap[nodeClusterId].push(node)
                } else {
                    clusterMap[nodeClusterId] = []
                    clusterMap[nodeClusterId].push(node)
                }
            })

            // console.log(clusterMap)
        }

        function onMouseOverHullMenuNode(clusterId) {
            if (!selectedClusterHullIds.includes(clusterId)) {
                addHighlightToSVGCircle(clusterId)
            }
            hoveredClusterHullId = clusterId
            simulationUpdate()
        }

        function onMouseOutHullMenuNode(clusterId) {
            if (!selectedClusterHullIds.includes(clusterId)) {
                removeHighlightFromSVGCircle(clusterId)
            }
            hoveredClusterHullId = undefined
            simulationUpdate()
        }

        function addHighlightToSVGCircle(clusterId) {
            let hullNodeSVG = $("#clusterHullNodeSVGCircle-" + clusterId)
            hullNodeSVG.attr('stroke', 'yellow')
            hullNodeSVG.attr('stroke-width', '2')
        }

        function removeHighlightFromSVGCircle(clusterId) {
            let hullNodeSVG = $("#clusterHullNodeSVGCircle-" + clusterId)
            hullNodeSVG.attr('stroke', 'black')
            hullNodeSVG.attr('stroke-width', '1')
        }

        function onClickHullMenuNode(clusterId) {
            if (selectedClusterHullIds.includes(clusterId)) {
                removeItemAll(selectedClusterHullIds, clusterId)
                removeHighlightFromSVGCircle(clusterId)
            } else {
                selectedClusterHullIds.push(clusterId)
                addHighlightToSVGCircle(clusterId)
            }
            simulationUpdate()
        }

        function createClusterHullMenu() {
            // check if there is at least one cluster
            if ("0" in clusterMap) {
                // build menu
                let clusterMenuHtml = "<div id=\"clusterHullContainer\"> \
                                        <div class=\"row\">"

                clusterMenuHtml += "<div class=\"svg-column\">"

                // insert SVG circles
                let iteration = 0
                Object.keys(clusterMap).forEach(function(key) {

                    if (iteration < maxClusterHulls) {
                        let firstNode = clusterMap[key][0]
                        let color = nodeColorByModularity(firstNode)

                        let svgElement = "<svg onmouseover=\"onMouseOverHullMenuNode(" + key + ")\" onmouseout=\"onMouseOutHullMenuNode(" + key + ")\" onclick=\"onClickHullMenuNode(" + key + ")\" height=\"16px\" width=\"16px\" viewBox=\"0 0 18 18\"><circle id=\"clusterHullNodeSVGCircle-" + key + "\" cx=\"5\" cy=\"10\" r=\"4\" \
                                stroke=\"black\" stroke-width=\"1\" fill=\""
                        svgElement += color
                        svgElement += "\" /></svg>"
                        clusterMenuHtml += svgElement
                    }
                    iteration += 1
                });

                // finish menu and append to div
                clusterMenuHtml += "</div></div></div>"
                d3.select("#clusterHullMenu").html(clusterMenuHtml)

                // add tooltips to cluster hull nodes
                iteration = 0
                Object.keys(clusterMap).forEach(function(clusterId) {
                    if (iteration < maxClusterHulls) {
                        let clusterToolTipDescription = "<u>Cluster metrics</u><br>"
                        let clusterMetrics = clusterMetricsMap[clusterId]

                        // TODO: check why clusterMetrics can be undefined
                        if (clusterMetrics !== undefined) {
                            // add all cluster metrics that we can find
                            Object.keys(clusterMetrics).forEach(function(clusterMetric) {
                                let metricPrettyName = clusterMetric.replace(/_/gi, " ").replace(/metric/gi, "")
                                clusterToolTipDescription += metricPrettyName + ": " + "<b>" + clusterMetrics[clusterMetric] + "</b>" + "<br>"
                            })

                            $('#' + 'clusterHullNodeSVGCircle-' + clusterId).attr('data-bs-toggle', 'tooltip')
                            $('#' + 'clusterHullNodeSVGCircle-' + clusterId).attr('data-bs-title', clusterToolTipDescription)
                            $('#' + 'clusterHullNodeSVGCircle-' + clusterId).attr('data-bs-html', 'true')
                            $('#' + 'clusterHullNodeSVGCircle-' + clusterId).attr('data-bs-placement', 'bottom')

                        }
                    }
                })
            }

            const tooltipTriggerList = document.querySelectorAll('[data-bs-toggle="tooltip"]')
            const tooltipList = [...tooltipTriggerList].map(tooltipTriggerEl => new bootstrap.Tooltip(tooltipTriggerEl))
        }

        function getPointArrayForClusterId(id) {
            let pointArray = []
            let clusterId = id.toString()

            if (clusterId in clusterMap) {
                clusterMap[clusterId].forEach(function(node, i) {
                    pointArray.push([node.x, node.y])
                })
            }
            return pointArray
        }

        // calculate hull
        function getHullFromPointArray(pointArray) {
            let hullArray = hull(pointArray, 60)
            return hullArray
        }

        /**
         * * MARK: - Translations on canvas
         */
        function translateCanvas(direction) {
            switch (direction) {
                case 'left':
                    transform.x += 100
                    simulationUpdate()
                    break;

                case 'down':
                    transform.y -= 100
                    simulationUpdate()
                    break;

                case 'right':
                    transform.x -= 100
                    simulationUpdate()
                    break;

                case 'up':
                    transform.y += 100
                    simulationUpdate()
                    break;
            }
        }

        /**
         * * MARK: - Adjusting style 
         */

        function unselectedOpacityChange(val) {
            unselectedNodesOpacity = val / 100.0
            simulationUpdate()
        }

        /**
         * * MARK: - Zooming and scaling on canvas
         */
        function zoomed(event) {
            transform = event.transform;
            simulationUpdate();
        }

        function zoomIn() {
            d3.select(graphCanvas)
                .call(zoom_handler.scaleBy, 2)
                .call(d3.zoom().scaleExtent([1 / 10, 8]).on("zoom", zoomed))
            simulationUpdate()
        }

        function zoomOut() {
            d3.select(graphCanvas)
                .call(zoom_handler.scaleBy, 0.5)
                .call(d3.zoom().scaleExtent([1 / 10, 8]).on("zoom", zoomed))
            simulationUpdate()
        }

        startWithGraph(currentGraphType)
        zoomOut() // initialliy zoom out a bit

        /**
         * * MARK: - Called on startup an d every time you change a graph
         */
        function startWithGraph(graphType, chargeForce = currentChargeForce, linkDistance = currentLinkDistance) {

            activeMetrics = []
            currentMetricKeys = []

            currentGraphType = graphType

            currentLinkDistance = linkDistance
            currentChargeForce = chargeForce
            currentLinkDistance = linkDistance

            resetSimulationData()

            currentGraph = JSON.parse(JSON.stringify(graphData[graphType]['graph']))
            statistics = graphData[graphType]['statistics']
            overall_metric_results = graphData[graphType]['overall_metric_results']
            clusterMetricsMap = graphData[graphType]['cluster_metrics_map']

            addGitMetricToFileNodes()

            createStatistics();
            createOverallMetricResults();

            currentGraph.nodes.forEach(function(d, i) {
                d.radius = radius

                if (!d.hasOwnProperty('metrics')) {
                    d.metrics = {}
                }

                for (let key in d) {

                    if (key.includes('metric_')) {
                        d.metrics[key] = d[key]
                        if (!currentMetricKeys.includes(key)) {
                            // do not include tag/tfidf metrics in the 'apply metrics' dropDown menu
                            if (!key.includes('metric_tag')) {
                                currentMetricKeys.push(key)
                            }                            
                        }
                    }
                }
            });

            setupGraphClustersById();
            
            createClusterHullMenu();
            createMetricsMenuEntries();

            updateAppUI()
            
            enableSearchInput();
            enableNodeSelection();

            addToolTipsToMetricEntries();
            addToolTipsToHeatMap();
            addToolTipToShortcuts();
            addTooltipUnselectedOpacity();
            addTooltipSemanticSearch();
            addTooltipClusterHulls();

            currentGraph.links.forEach((d) => {
                linkedByIndex[`${d.source},${d.target}`] = true;
            });

            simulation = d3.forceSimulation()
                .force("center", d3.forceCenter(graphWidth / 4, height / 4))
                .force("x", d3.forceX(graphWidth / 2).strength(0.1))
                .force("y", d3.forceY(height / 2).strength(0.1))
                .force("charge", d3.forceManyBody().strength(currentChargeForce))
                .force("link", d3.forceLink()
                    .strength(1)
                    .distance(currentLinkDistance)
                    .id(function(d) {
                        return d.id;
                    }))
                .alphaTarget(0)
                .alphaDecay(0.05)

            addGraphTypeSelectionToMenu()

            addTooltipProjectInfo();
            addTooltipGraphInfo();
            
            d3.select(graphCanvas)
                .call(d3.drag().subject(dragsubject).on("start", dragstarted).on("drag", dragged).on("end", dragended))
                .call(d3.zoom().scaleExtent([1 / 10, 8]).on("zoom", zoomed))

            function dragsubject(event) {

                let i,
                    x = transform.invertX(event.x),
                    y = transform.invertY(event.y),
                    dx,
                    dy;

                for (i = currentGraph.nodes.length - 1; i >= 0; --i) {
                    node = currentGraph.nodes[i];
                    dx = x - node.x;
                    dy = y - node.y;

                    if (dx * dx + dy * dy < radius * radius) {

                        node.x = transform.applyX(node.x);
                        node.y = transform.applyY(node.y);

                        return node;
                    }
                }
            }

            function dragstarted(event) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                event.subject.fx = transform.invertX(event.x);
                event.subject.fy = transform.invertY(event.y);
            }

            function dragged(event) {
                event.subject.fx = transform.invertX(event.x);
                event.subject.fy = transform.invertY(event.y);
            }

            function dragended(event) {
                if (!event.active) simulation.alphaTarget(0);
                event.subject.fx = null;
                event.subject.fy = null;
            }
            
            d3.select("canvas").on("mousemove", (event) => {
                let p = d3.pointer(event);
                let invX = transform.invertX(p[0])
                let invY = transform.invertY(p[1])

                let foundNode = simulation.find(transform.invertX(p[0]), transform.invertY(p[1]));

                // check within a close area if hovered point is nearby of foundNode
                if ((Math.abs(foundNode.x - invX) < radius) && (Math.abs(foundNode.y - invY) < radius)) {
                    closeNode = simulation.find(transform.invertX(p[0]), transform.invertY(p[1]));
                } else {
                    closeNode = null
                }

                simulationUpdate();
            })

            simulation.nodes(currentGraph.nodes)
                .on("tick", simulationUpdate);

            simulation.force("link")
                .links(currentGraph.links);
        }

        // Based on https://bl.ocks.org/jodyphelan/5dc989637045a0f48418101423378fbd
        function simulationUpdate() {

            context.save();

            context.clearRect(0, 0, graphWidth, height);
            context.translate(transform.x, transform.y);
            context.scale(transform.k, transform.k);

            // draw heatmap
            if (mergedHeatmapIsActive() || normalHeatmapIsActive() || churnHeatmapIsActive() || hotspotHeatmapIsActive()) {
                drawHeatMap(context)
            }

            // this is pretty cpu hungry
            drawHulls(context)

            // draw edges
            drawEdges(context)

            // Draw nodes
            drawNodes(context)

            context.restore();
        }

        // draw a single cluster hull as a polygon 
        function drawHull(context, clusterId) {
            let pointArray = getPointArrayForClusterId(clusterId)
            let hullArray = getHullFromPointArray(pointArray)
            let firstNodeInCluster = clusterMap[clusterId][0]
            context.fillStyle = nodeColorByModularity(firstNodeInCluster, 0.2)

            context.beginPath();

            let firstPoint = hullArray[0]
            context.moveTo(firstPoint[0], firstPoint[1]);

            hullArray.forEach(function(arrayElement, i) {
                context.lineTo(arrayElement[0], arrayElement[1]);
            })

            context.closePath();
            context.fill();
        }

        // draw all required cluster hulls (selected/hovered nodes from the menu)
        function drawHulls(context) {

            // draw a hull if someone hovers ofer a hull menu cluster node 
            if (hoveredClusterHullId !== undefined) {
                drawHull(context, hoveredClusterHullId)
            }

            // draw every hull was was selected by a mouse click before 
            selectedClusterHullIds.forEach(clusterId => {
                drawHull(context, clusterId)
            })
        }

        /**
         * * MARK: - Handling of data structures
         */
        function prepareGraphStructures() {
            if (typeof file_result_dependency_graph !== 'undefined') {
                graphData['file_result_dependency_graph'] = {}
                graphData['file_result_dependency_graph']['graph'] = file_result_dependency_graph
                graphData['file_result_dependency_graph']['statistics'] = file_result_dependency_graph_statistics
                graphData['file_result_dependency_graph']['overall_metric_results'] =
                    file_result_dependency_graph_overall_metric_results
                graphData['file_result_dependency_graph']['cluster_metrics_map'] = file_result_dependency_graph_cluster_metrics_map
                currentGraphType = 'file_result_dependency_graph'
            }

            if (typeof entity_result_dependency_graph !== 'undefined') {
                graphData['entity_result_dependency_graph'] = {}
                graphData['entity_result_dependency_graph']['graph'] = entity_result_dependency_graph
                graphData['entity_result_dependency_graph']['statistics'] = entity_result_dependency_graph_statistics
                graphData['entity_result_dependency_graph']['overall_metric_results'] =
                    entity_result_dependency_graph_overall_metric_results
                graphData['entity_result_dependency_graph']['cluster_metrics_map'] = entity_result_dependency_graph_cluster_metrics_map
                currentGraphType = 'entity_result_dependency_graph'
            }

            if (typeof entity_result_inheritance_graph !== 'undefined') {
                graphData['entity_result_inheritance_graph'] = {}
                graphData['entity_result_inheritance_graph']['graph'] = entity_result_inheritance_graph
                graphData['entity_result_inheritance_graph']['statistics'] = entity_result_inheritance_graph_statistics
                graphData['entity_result_inheritance_graph']['overall_metric_results'] =
                    entity_result_inheritance_graph_overall_metric_results
                graphData['entity_result_inheritance_graph']['cluster_metrics_map'] = entity_result_inheritance_graph_cluster_metrics_map
            }

            if (typeof entity_result_complete_graph !== 'undefined') {
                graphData['entity_result_complete_graph'] = {}
                graphData['entity_result_complete_graph']['graph'] = entity_result_complete_graph
                graphData['entity_result_complete_graph']['statistics'] = entity_result_complete_graph_statistics
                graphData['entity_result_complete_graph']['overall_metric_results'] =
                    entity_result_complete_graph_overall_metric_results
                graphData['entity_result_complete_graph']['cluster_metrics_map'] = entity_result_complete_graph_cluster_metrics_map
            }

            if (typeof filesystem_graph !== 'undefined') {
                graphData['filesystem_graph'] = {}
                graphData['filesystem_graph']['graph'] = filesystem_graph
                graphData['filesystem_graph']['statistics'] = filesystem_graph_statistics
                graphData['filesystem_graph']['overall_metric_results'] = filesystem_graph_overall_metric_results
                graphData['filesystem_graph']['cluster_metrics_map'] = filesystem_graph_cluster_metrics_map
            }
        }

        function resetSimulationData() {
            if (simulation !== undefined) {
                simulation.stop()
            }

            metricKeys = nodesData = linksData = []
            simulation = undefined
        }

        // based on https://bocoup.com/blog/smoothly-animate-thousands-of-points-with-html5-canvas-and-d3 / Peter Beshai
        // basically animates the increase/decrease of the node radius based on chosen metrics
        function animateRadiusWithMetric(metricName) {

            let addedMetric = true
            if (activeMetrics.includes(metricName)) {
                removeItemAll(activeMetrics, metricName)
                addedMetric = false
            } else {
                activeMetrics.push(metricName)
                addedMetric = true
            }

            // console.log(metricName)
            const duration = 250;
            const ease = d3.easeCubic;

            timer = d3.timer((elapsed) => {
                // compute how far through the animation we are (0 to 1)
                const t = Math.min(1, ease(elapsed / duration));

                // update point positions (interpolate between source and target)
                currentGraph.nodes.forEach(node => {
                    if (metricName in node.metrics) {
                        // this resets all nodes back to the default radius
                        let newRadius = 0

                        // now interpolate for every x between f(0) and f(1): f(x) = f(0) * (1-x) + f(1) * x
                        if (addedMetric) {                            
                            newRadius = node.radius * (1 - t) + (node.radius + (node.metrics[metricName] * analysis_config['metrics']['radius_multiplication'][metricName] )) * t;
                            
                            if (newRadius > node.radius) {
                                node.radius = newRadius
                            }

                        } else {
                            newRadius = node.radius * (1 - t) + (node.radius - (node.metrics[metricName] * analysis_config['metrics']['radius_multiplication'][metricName] )) * t;
                            if (newRadius > radius) {
                                node.radius = newRadius
                            } else {
                                node.radius = radius
                            }
                        }
                    }
                });

                // if this animation is over
                if (t === 1) {
                    // always make sure that node sizes return to default if no metric is active
                    if (activeMetrics.length == 0) {
                        currentGraph.nodes.forEach(node => {
                            node.radius = radius
                        })
                    }

                    // stop this timer since we are done animating.
                    timer.stop();
                }

                // update what is drawn on screen
                simulationUpdate();
            });
        }

        /**
         * * MARK: - Create/update the HTML/Bootstrap UI
         */

        function cancelNodeSearch() {
            $('#inputNodeSearch').val('')
            $('#inputNodeSearchLabel').text('Search inactive')
            searchString = ""

            searchTerms = []

            isSearching = false
            simulationUpdate()
        }

        // setup keyboard shortcut keys for node selection
        // shift + 's' key: select/unselect node
        // shift + 'e' key: expand selected nodes level deeper
        // shift + 'h' key: expand hovered nodes level deeper
        // shift + 'r' key: reset current selection
        // shift + 'f' key: fade unselected nodes
        function enableNodeSelection() {
            let keySelectUnselect = 'S'
            let keyExpandSelection = 'E'
            let keyExpandHoveredNode = 'H'
            let keyResetCurrentSelection = 'R'
            let keyFadeUnselectedNodes = 'F'

            d3.select('body')
                .on("keydown", function(event) { 



                    if (event.key == keySelectUnselect) {
                        if (closeNode != null) {
                            if (closeNode.id.toLowerCase() in selectedNodesMap) {
                                delete selectedNodesMap[closeNode.id.toLowerCase()]
                            } else {
                                selectedNodesMap[closeNode.id.toLowerCase()] = true
                            }
                            simulationUpdate()
                        }
                    }

                    if (event.key == keyExpandSelection) {
                        if (selectedNodesMap.length != 0) {
                            let newSelectedNodesMap = {...selectedNodesMap}
                            currentGraph.links.forEach(function(d) {
                                if (d.source.id.toLowerCase() in selectedNodesMap || d.target.id.toLowerCase() in selectedNodesMap) {
                                    newSelectedNodesMap[d.source.id.toLowerCase()] = true
                                    newSelectedNodesMap[d.target.id.toLowerCase()] = true
                                }
                            })
                            selectedNodesMap = newSelectedNodesMap
                            simulationUpdate()
                        }
                    }

                    if (event.key == keyExpandHoveredNode) {
                        if (closeNode != null) {
                            selectedNodesMap[closeNode.id.toLowerCase()] = true
                            let newSelectedNodesMap = {...selectedNodesMap}
                            currentGraph.links.forEach(function(d) {
                                if (d.source.id == closeNode.id || d.target.id == closeNode.id) {
                                    newSelectedNodesMap[d.source.id.toLowerCase()] = true
                                    newSelectedNodesMap[d.target.id.toLowerCase()] = true
                                }
                            })
                            selectedNodesMap = newSelectedNodesMap
                            simulationUpdate()
                        }
                    }

                    if (event.key == keyResetCurrentSelection) {
                        selectedNodesMap = {}
                        simulationUpdate()
                    }

                    if (event.key == keyFadeUnselectedNodes) {
                        fadeUnselectedNodes = !fadeUnselectedNodes
                        if (fadeUnselectedNodes == true) {
                            $("#li-unselected-opacity").removeClass('d-none');
                            $("#unselected-opacity").removeClass('d-none');
                            $('#fadeUnselectedNodesLabelText').html('<b>f fading unselected nodes</b>')
                            
                        } else {
                            $("#li-unselected-opacity").addClass('d-none');
                            $("#unselected-opacity").addClass('d-none');
                            $('#fadeUnselectedNodesLabelText').html('<b>f</b> fade unselected nodes')
                        }
                        simulationUpdate()
                    }
            });
        }

        function enableSearchInput() {
            $('#inputNodeSearchLabel').text('Search inactive')
            $('#inputNodeSearch').on('keyup change', function() {
                searchString = $(this).val().toLowerCase()

                searchTerms = searchString.split(" ")
                searchTerms = searchTerms.filter(Boolean);
                // console.log(searchTerms)
                 
                searchResults = 0
                if (searchString.length > 0 && searchTerms.length > 0) {
                    isSearching = true
                    simulationUpdate()
                    $('#inputNodeSearchLabel').text(searchResults + ' nodes found')

                } else {
                    isSearching = false
                    simulationUpdate()
                    $('#inputNodeSearchLabel').text('Search inactive')
                }
            })

            $('#inputNodeSearchCancel').on('click', function() {
                cancelNodeSearch()
            })
        }

        function addToolTipsToMetricEntries() {
            $('#badge_metric_sloc_in_file').attr('data-bs-toggle', 'tooltip')
            $('#badge_metric_sloc_in_file').attr('data-bs-title', description_metric_sloc_in_file)
            $('#badge_metric_sloc_in_file').attr('data-bs-html', 'true')
            $('#badge_metric_sloc_in_file').attr('data-bs-placement', 'bottom')

            $('#badge_metric_sloc_in_entity').attr('data-bs-toggle', 'tooltip')
            $('#badge_metric_sloc_in_entity').attr('data-bs-title', description_metric_sloc_in_file)
            $('#badge_metric_sloc_in_entity').attr('data-bs-html', 'true')
            $('#badge_metric_sloc_in_entity').attr('data-bs-placement', 'bottom')

            $('#badge_metric_number_of_methods_in_file').attr('data-bs-toggle', 'tooltip')
            $('#badge_metric_number_of_methods_in_file').attr('data-bs-title', description_metric_number_of_methods)
            $('#badge_metric_number_of_methods_in_file').attr('data-bs-html', 'true')
            $('#badge_metric_number_of_methods_in_file').attr('data-bs-placement', 'bottom')

            $('#badge_metric_number_of_methods_in_entity').attr('data-bs-toggle', 'tooltip')
            $('#badge_metric_number_of_methods_in_entity').attr('data-bs-title', description_metric_number_of_methods)
            $('#badge_metric_number_of_methods_in_entity').attr('data-bs-html', 'true')
            $('#badge_metric_number_of_methods_in_entity').attr('data-bs-placement', 'bottom')

            // TODO
            $('#badge_metric_fan_in_dependency_graph').attr('title', description_metric_fan_in)
            // $('#badge_metric_fan_in_dependency_graph').tooltip();
            $('#badge_metric_fan_in_complete_graph').attr('title', description_metric_fan_in)
            // $('#badge_metric_fan_in_complete_graph').tooltip();
            $('#badge_metric_fan_in_inheritance_graph').attr('title', description_metric_fan_in)
            // $('#badge_metric_fan_in_inheritance_graph').tooltip();

            $('#badge_metric_fan_out_dependency_graph').attr('title', description_metric_fan_out)
            // $('#badge_metric_fan_out_dependency_graph').tooltip();
            $('#badge_metric_fan_out_complete_graph').attr('title', description_metric_fan_out)
            // $('#badge_metric_fan_out_complete_graph').tooltip();
            $('#badge_metric_fan_out_inheritance_graph').attr('title', description_metric_fan_out)
            // $('#badge_metric_fan_out_inheritance_graph').tooltip();

            $('#badge_metric_file_result_dependency_graph_louvain_modularity_file').attr('title', description_metric_louvain_modularity)
            // $('#badge_metric_file_result_dependency_graph_louvain_modularity_file').tooltip();

            $('#badge_metric_entity_result_dependency_graph_louvain_modularity_in_entity').attr('title', description_metric_louvain_modularity)
            // $('#badge_metric_entity_result_dependency_graph_louvain_modularity_in_entity').tooltip();

            $('#badge_metric_entity_result_inheritance_graph_louvain_modularity_in_entity').attr('title', description_metric_louvain_modularity)
            // $('#badge_metric_entity_result_inheritance_graph_louvain_modularity_in_entity').tooltip();

            $('#badge_metric_entity_result_complete_graph_louvain_modularity_in_entity').attr('title', description_metric_louvain_modularity)
            // $('#badge_metric_entity_result_complete_graph_louvain_modularity_in_entity').tooltip();

            $('#badge_metric_entity_result_complete_graph_louvain_modularity_in_entity').attr('title', description_metric_louvain_modularity)
            // $('#badge_metric_entity_result_complete_graph_louvain_modularity_in_entity').tooltip();

            const tooltipTriggerList = document.querySelectorAll('[data-bs-toggle="tooltip"]')
            const tooltipList = [...tooltipTriggerList].map(tooltipTriggerEl => new bootstrap.Tooltip(tooltipTriggerEl))
        }

        function addToolTipsToHeatMap() {
            const badgeHeatmapNormalTooltip = new bootstrap.Tooltip(document.getElementById('badge_heat_map_normal'), {});
            badgeHeatmapNormalTooltip._config.title = description_heat_map_normal

            const badgeHeatmapHybridTooltip = new bootstrap.Tooltip(document.getElementById('badge_heat_map_hybrid'), {});
            badgeHeatmapHybridTooltip._config.title = description_heat_map_hybrid
        }

        function addToolTipToShortcuts() {
            const badgeShortcutsTooltip = new bootstrap.Tooltip(document.getElementById('badge_shortcuts'), {});
            badgeShortcutsTooltip._config.template = wide_tooltip_template
            badgeShortcutsTooltip._config.title = description_shortcuts_tooltip
        }

        function addTooltipUnselectedOpacity() {
            const badgeUnselectedOpacityTooltip = new bootstrap.Tooltip(document.getElementById('badge_unselected_opacity'), {});
            badgeUnselectedOpacityTooltip._config.title = description_unselected_opacity
        }

        function addTooltipSemanticSearch() {
            const badgeSemanticSearchTooltip = new bootstrap.Tooltip(document.getElementById('badge_semantic_search'), {});
            badgeSemanticSearchTooltip._config.title = description_semantic_search
        }

        function addTooltipClusterHulls() {
            const badgeBadgeClusterHullsTooltip = new bootstrap.Tooltip(document.getElementById('badge_cluster_hulls'), {});
            badgeBadgeClusterHullsTooltip._config.title = description_cluster_hulls
        }

        function addTooltipProjectInfo() {
            let configProjectName = analysis_config['project_name']
            let analysisName = getAnalysisName()
            let configAnalysisDateTime = analysis_config['analysis_date']

            description_project_info = "<strong>Project:</strong> " + configProjectName + "<br>" + "<strong>Analysis:</strong> " + analysisName + "<br>" + "<strong>Date:</strong> " + configAnalysisDateTime          
            const badgeProjectInfoTooltip = new bootstrap.Tooltip(document.getElementById('badge_project_info'), {});
            badgeProjectInfoTooltip._config.title = description_project_info
        }
        
        function addTooltipGraphInfo() {
            description_graph_info = "<strong>Graph nodes:</strong> " + currentGraph.nodes.length + "<br>" + "<strong>Graph edges:</strong> " + currentGraph.links.length + "<br>" + "<strong>Charge force:</strong> " + currentChargeForce
            const badgeGraphInfoTooltip = new bootstrap.Tooltip(document.getElementById('badge_graph_info'), {});
            badgeGraphInfoTooltip._config.title = description_graph_info
        }

        function createStatistics() {
            // create statistics table
            statistics_html = ""
            for (let key in statistics) {
                if (statistics.hasOwnProperty(key)) {
                    statistics_html += "<tr>"

                    statistics_html += "<td>"
                    statistics_html += key
                    statistics_html += "</td>"

                    statistics_html += "<td>"
                    statistics_html += statistics[key]
                    statistics_html += "</td>"

                    statistics_html += "</tr>"
                }
            }
            d3.select("#tbody-statistics").html(statistics_html)
        }

        function createOverallMetricResults() {
            // create metrics table
            metrics_html = ""
            for (let key in overall_metric_results) {
                if (overall_metric_results.hasOwnProperty(key)) {
                    metrics_html += "<tr>"

                    metrics_html += "<td>"
                    metrics_html += key
                    metrics_html += "</td>"

                    metrics_html += "<td>"

                    let valueString = String(overall_metric_results[key])
                    if (valueString.length > 30) {
                        valueString = valueString.substring(0, 32) + '...';
                    }

                    metrics_html += String(valueString)
                    metrics_html += "</td>"

                    metrics_html += "</tr>"
                }
            }
            d3.select("#tbody-metrics").html(metrics_html)
        }

        function createMetricsMenuEntries() {
            // create apply metrics menu entries
            applyMetricHtml = ""

            for (let key in currentMetricKeys) {
                applyMetricHtml += '<li> &nbsp; <input data-value="'
                applyMetricHtml += currentMetricKeys[key]
                applyMetricHtml += '" type="checkbox" onclick="animateRadiusWithMetric(\''
                applyMetricHtml += currentMetricKeys[key]
                applyMetricHtml += '\');"/>&nbsp; <span id="'
                applyMetricHtml += '" style="font-size:10px;">'

                let visibleMetricName = currentMetricKeys[key].replace(/_/gi, " ").replace(/metric/gi, "")
                
                // reformat the visible metric name if necessary
                if (visibleMetricName.includes('louvain modularity')) { visibleMetricName = 'louvain modularity' }
                
                applyMetricHtml += visibleMetricName
                applyMetricHtml += '</span> <small><span id="'
                applyMetricHtml += 'badge_' + currentMetricKeys[key]
                applyMetricHtml += '" data-bs-toggle="tooltip" data-bs-placement="bottom" title="" class="badge badge-primary badge-pill text-bg-primary"> ?</span> </small> &nbsp;</li>'
            }

            d3.select("#dropdown-apply-metric").html(applyMetricHtml)
        }

        function getAnalysisName() {
            let analysisName = analysis_config['analysis_name']
            if (analysisName.length > 24) {
                analysisName = analysisName.slice(0, 24) + '...'
            }
            return analysisName
        }

        function addGraphTypeSelectionToMenu() {
            graphSelectHtml = ""
            for (let key in graphData) {
                graphSelectHtml += '<button class="dropdown-item btn-sm" style="font-size: 10px;" type="button" onclick="startWithGraph(\''
                graphSelectHtml += key
                graphSelectHtml += '\');">'
                graphSelectHtml += key.replace(/_/gi, " ")
                graphSelectHtml += "</button>"
            }

            d3.select("#dropdown-graph").html(graphSelectHtml)
            d3.select("#selectedGraph").text(currentGraphType.replace(/_/gi, " ").slice(0, 20) + '...')
        }

        function increaseCurrentChargeForce() {
            if (currentChargeForce < -50) {
                currentChargeForce += 50
                d3.select("#chargeForce").text(currentChargeForce)
                simulation.force("charge", d3.forceManyBody().strength(currentChargeForce))
                simulation.alpha(1).restart();
            }
        }

        function decreaseCurrentChargeForce() {
            currentChargeForce -= 50
            d3.select("#chargeForce").text(currentChargeForce)
            simulation.force("charge", d3.forceManyBody().strength(currentChargeForce))
            simulation.alpha(1).restart();
        }

        /**
         * * MARK: - heatmap
         */

        function normalHeatmapIsActive() { return heatmapActive }
        function mergedHeatmapIsActive() { return heatmapMerged }
        function churnHeatmapIsActive() { return heatmapChurn }
        function hotspotHeatmapIsActive() { return heatmapHotspot }

        function initSemanticSearchSwitch() {
            $("#switchAddSemanticSearch").on('change', function() {
                addSemanticSearch = $(this).is(':checked');
                searchResults = 0
                simulationUpdate();
                $('#inputNodeSearchLabel').text(searchResults + ' nodes found')                
            })
        }

        function initContributorSearchSwitch() {
            $("#switchAddContributorSearch").on('change', function() {
                addContributorSearch = $(this).is(':checked');
                searchResults = 0
                simulationUpdate();
                $('#inputNodeSearchLabel').text(searchResults + ' nodes found')                
            })
        }

        function initAppConfig() {
            $('#configEmergeVersion').text('Emerge ' + analysis_config['emerge_version'])
        }

        function updateAppUI() {
            if (fadeUnselectedNodes == true) {
                $("#li-unselected-opacity").removeClass('d-none');
                $("#unselected-opacity").removeClass('d-none');
            } else {
                $("#li-unselected-opacity").addClass('d-none');
                $("#unselected-opacity").addClass('d-none');
            }

            // currently only show git heatmaps for file dependency graph
            if (currentGraphType.includes('file_result_dependency_graph')) {
                $("#formSwitchChurnHeatmap").removeClass('d-none');
                $("#formSwitchHotspotHeatmap").removeClass('d-none');
            } else {
                $("#formSwitchChurnHeatmap").addClass('d-none');
                $("#formSwitchHotspotHeatmap").addClass('d-none');
            }
        }

        function initAppUI() {
            updateAppUI()
            initGitMetricsForDateRange()
            initDateRangeUI()

            initModals()
        }

        // TODO
        function initTemporalEdges() {

            let temporal_edges = commit_metrics.reduce(function(ids, obj){
                if(obj.links.length !== 0){
                    ids.push(obj.links);
                }
                return ids;
            }, []);

            temporal_edges = temporal_edges.flat()
            // console.log(temporal_edges)

            if (simulation !== undefined) {
                simulation.stop()
            }

            graphData['file_result_dependency_graph']['graph']['links'] = temporal_edges

            currentGraph = JSON.parse(JSON.stringify(graphData['file_result_dependency_graph']['graph']))
            currentGraph.links = temporal_edges  //[...currentGraph.links, ...temporal_edges];

            startWithGraph('file_result_dependency_graph')            

        }

        function toggleTemporalEdges(toggle) {

        } 

        function initAddTemporalSwitch() {
            $("#switchTemporalEdges").on('change', function() {
                if ($(this).is(':checked')) {
                    addTemporalEdges = true
                    initTemporalEdges()
                    showDebugToast('temp edges: ' + addTemporalEdges)
                } else {
                    addTemporalEdges = false
                    showDebugToast('temp edges: ' + addTemporalEdges)
                }

                simulationUpdate();
            })
        }

        

        function initHeatmapSwitches() {
            // normal heatmap
            $("#switchActivateHeatmap").on('change', function() {
                if ($(this).is(':checked')) {
                    heatmapActive = true
                    if ($("#switchMergeHeatmap").is(':checked')) {
                        $("#switchMergeHeatmap").prop('checked', false);
                        heatmapMerged = false
                    }

                    if ($("#switchChurnHeatmap").is(':checked')) {
                        $("#switchChurnHeatmap").prop('checked', false);
                        heatmapChurn = false
                    }

                    if ($("#switchHotspotHeatmap").is(':checked')) {
                        $("#switchHotspotHeatmap").prop('checked', false);
                        heatmapHotspot = false
                    }
                } else {
                    heatmapActive = false
                }

                simulationUpdate();
            });

            // hybrid/merged heatmap
            $("#switchMergeHeatmap").on('change', function() {
                if ($(this).is(':checked')) {
                    heatmapMerged = true
                    if ($("#switchActivateHeatmap").is(':checked')) {
                        $("#switchActivateHeatmap").prop('checked', false);
                        heatmapActive = false
                    }

                    if ($("#switchChurnHeatmap").is(':checked')) {
                        $("#switchChurnHeatmap").prop('checked', false);
                        heatmapChurn = false
                    }

                    if ($("#switchHotspotHeatmap").is(':checked')) {
                        $("#switchHotspotHeatmap").prop('checked', false);
                        heatmapHotspot = false
                    }
                } else {
                    heatmapMerged = false
                }

                simulationUpdate();
            });

            // churn heatmap
            $("#switchChurnHeatmap").on('change', function() {
                if ($(this).is(':checked')) {
                    heatmapChurn = true
                    if ($("#switchActivateHeatmap").is(':checked')) {
                        $("#switchActivateHeatmap").prop('checked', false);
                        heatmapActive = false
                    }

                    if ($("#switchMergeHeatmap").is(':checked')) {
                        $("#switchMergeHeatmap").prop('checked', false);
                        heatmapMerged = false
                    }

                    if ($("#switchHotspotHeatmap").is(':checked')) {
                        $("#switchHotspotHeatmap").prop('checked', false);
                        heatmapHotspot = false
                    }
                } else {
                    heatmapChurn = false
                }

                simulationUpdate();
            });

            // hotspot heatmap
            $("#switchHotspotHeatmap").on('change', function() {
                if ($(this).is(':checked')) {
                    heatmapHotspot = true
                    if ($("#switchActivateHeatmap").is(':checked')) {
                        $("#switchActivateHeatmap").prop('checked', false);
                        heatmapActive = false
                    }

                    if ($("#switchMergeHeatmap").is(':checked')) {
                        $("#switchMergeHeatmap").prop('checked', false);
                        heatmapMerged = false
                    }

                    if ($("#switchChurnHeatmap").is(':checked')) {
                        $("#switchChurnHeatmap").prop('checked', false);
                        heatmapChurn = false
                    }
                } else {
                    heatmapHotspot = false
                }

                simulationUpdate();
            });

        }

        /**
         * * MARK: - Helper functions
         */

        // borrowed from https://stackoverflow.com/questions/5767325/how-can-i-remove-a-specific-item-from-an-array
        function removeItemAll(arr, value) {
            let i = 0;
            while (i < arr.length) {
                if (arr[i] === value) {
                    arr.splice(i, 1);
                } else {
                    ++i;
                }
            }
            return arr;
        }

        //https://stackoverflow.com/questions/21646738/convert-hex-to-rgba
        function hexToRGB(hex, alpha) {
            let r = parseInt(hex.slice(1, 3), 16),
                g = parseInt(hex.slice(3, 5), 16),
                b = parseInt(hex.slice(5, 7), 16);

            if (alpha) {
                return "rgba(" + r + ", " + g + ", " + b + ", " + alpha + ")";
            } else {
                return "rgb(" + r + ", " + g + ", " + b + ")";
            }
        }

        // Copyright 2021 Observable, Inc.
        // Released under the ISC license.
        // https://observablehq.com/@d3/multi-line-chart
        function LineChart(data, {
            x = ([x]) => x, // given d in data, returns the (temporal) x-value
            y = ([, y]) => y, // given d in data, returns the (quantitative) y-value
            z = () => 1, // given d in data, returns the (categorical) z-value
            title, // given d in data, returns the title text
            defined, // for gaps in data
            curve = d3.curveLinear, // method of interpolation between points
            marginTop = 20, // top margin, in pixels
            marginRight = 30, // right margin, in pixels
            marginBottom = 30, // bottom margin, in pixels
            marginLeft = 40, // left margin, in pixels
            width = 640, // outer width, in pixels
            height = 400, // outer height, in pixels
            xType = d3.scaleUtc, // type of x-scale
            xDomain, // [xmin, xmax]
            xRange = [marginLeft, width - marginRight], // [left, right]
            yType = d3.scaleLinear, // type of y-scale
            yDomain, // [ymin, ymax]
            yRange = [height - marginBottom, marginTop], // [bottom, top]
            yFormat, // a format specifier string for the y-axis
            yLabel, // a label for the y-axis
            zDomain, // array of z-values
            color = "currentColor", // stroke color of line, as a constant or a function of *z*
            strokeLinecap, // stroke line cap of line
            strokeLinejoin, // stroke line join of line
            strokeWidth = 1.5, // stroke width of line
            strokeOpacity, // stroke opacity of line
            mixBlendMode = "multiply", // blend mode of lines
            voronoi, // show a Voronoi overlay? (for debugging)
            id
        } = {}) {
            // Compute values.

            const X = d3.map(data, x);
            const Y = d3.map(data, y);
            const Z = d3.map(data, z);
            const O = d3.map(data, d => d);
            if (defined === undefined) defined = (d, i) => !isNaN(X[i]) && !isNaN(Y[i])  ;
            const D = d3.map(data, defined);
       
            // Compute default domains, and unique the z-domain.
            if (xDomain === undefined) xDomain = d3.extent(X);
            if (yDomain === undefined) yDomain = [0, d3.max(Y, d => typeof d === "string" ? +d : d)];
            if (zDomain === undefined) zDomain = Z;
            zDomain = new d3.InternSet(zDomain);
            
            // Omit any data not present in the z-domain.
            const I = d3.range(X.length).filter(i => zDomain.has(Z[i]));
            
            // Construct scales and axes.
            const xScale = xType(xDomain, xRange);
            const yScale = yType(yDomain, yRange);
            const xAxis = d3.axisBottom(xScale).ticks(width / 80).tickSizeOuter(0);
            const yAxis = d3.axisLeft(yScale).ticks(height / 60, yFormat);
            
            // Compute titles.
            const T = title === undefined ? Z : title === null ? null : d3.map(data, title);
            
            // Construct a line generator.
            const line = d3.line()
            .defined(i => D[i])
            .curve(curve)
            .x(i => xScale(X[i]))
            .y(i => yScale(Y[i]));
            
            const svg = d3.create("svg")
            .attr("id", id)
            .attr("width", width)
            .attr("height", height)
            .attr("viewBox", [0, 0, width, height])
            .attr("style", "max-width: 100%; height: auto; height: intrinsic;")
            .style("-webkit-tap-highlight-color", "transparent")
            .on("pointerenter", pointerentered)
            .on("pointermove", pointermoved)
            .on("pointerleave", pointerleft)
            .on("touchstart", event => event.preventDefault());
            
            // An optional Voronoi display (for fun).
            if (voronoi) svg.append("path")
            .attr("fill", "none")
            .attr("stroke", "#ccc")
            .attr("d", d3.Delaunay
            .from(I, i => xScale(X[i]), i => yScale(Y[i]))
            .voronoi([0, 0, width, height])
            .render());
            
            svg.append("g")
            .attr("transform", `translate(0,${height - marginBottom})`)
            .call(xAxis);
            
            svg.append("g")
            .attr("transform", `translate(${marginLeft},0)`)
            .call(yAxis)
            .call(g => g.select(".domain").remove())
            .call(voronoi ? () => {} : g => g.selectAll(".tick line").clone()
            .attr("x2", width - marginLeft - marginRight)
            .attr("stroke-opacity", 0.1))
            .call(g => g.append("text")
            .attr("x", -marginLeft)
            .attr("y", 10)
            .attr("fill", "currentColor")
            .attr("text-anchor", "start")
            .text(yLabel));

            const path = svg.append("g")
                .attr("fill", "none")
                .attr("stroke", typeof color === "string" ? color : null)
                .attr("stroke-linecap", strokeLinecap)
                .attr("stroke-linejoin", strokeLinejoin)
                .attr("stroke-width", strokeWidth)
                .attr("stroke-opacity", strokeOpacity)
            .selectAll("path")
            .data(d3.group(I, i => Z[i]))
            .join("path")
                //.style("mix-blend-mode", mixBlendMode)
                .attr("stroke", typeof color === "function" ? ([z]) => color(z) : null)
                .attr("d", ([, I]) => line(I));

            const dot = svg.append("g")
            .attr("display", "none")
            .attr("fill", "red");
            
            dot.append("circle")
            .attr("r", 2.5);
            
            dot.append("text")
            .attr("font-family", "sans-serif")
            .attr("font-size", 10)
            .attr("text-anchor", "middle")
            .attr("fill", "white") 
            .attr("y", -8);
            
            function pointermoved(event) {
                const [xm, ym] = d3.pointer(event);
                const i = d3.least(I, i => Math.hypot(xScale(X[i]) - xm, yScale(Y[i]) - ym)); // closest point
                path.style("stroke", ([z]) => Z[i] === z ? null : "dimgray").filter(([z]) => Z[i] === z).raise();
                dot.attr("transform", `translate(${xScale(X[i])},${yScale(Y[i])})`);
                if (T) dot.select("text").text(T[i]);
                svg.property("value", O[i]).dispatch("input", {bubbles: true});
            }
            
            function pointerentered() {
                path.style("mix-blend-mode", null).style("stroke", "lightyellow");
                dot.attr("display", null);
            }
            
            function pointerleft() {
                //path.style("mix-blend-mode", mixBlendMode).style("stroke", null);
                path.style("stroke", "lightsteelblue")
                dot.attr("display", "none");
                svg.node().value = null;
                svg.dispatch("input", {bubbles: true});
            }
            
            return Object.assign(svg.node(), {value: null});
        }

        function generateTimeSeriesChart() {

            let timeSeriesComplexity = []
            let timeSeriesChurn = []

            for (let i = gitMetricsIndexFrom; i < gitMetricsIndexTo; i++) {

                // prepare complexity data for chart
                for (const [key, value] of Object.entries(commit_metrics[i].ws_complexity)) {
                    if (key.includes(fileResultPrefixFull)) {

                        const matchingKey = key.replace(fileResultPrefix + "/", "").toLowerCase()
                        if (Object.keys(selectedNodesMap).length > 0) {
                            if ((matchingKey in selectedNodesMap) == false) {
                                continue
                            }
                        }

                        let timeSeriesComplexityEntry = {
                            'filepath' : key,
                            'wscomplexity' : value,
                            'date': commit_metrics[i].exact_date.replace(/_/g, "-") // TODO ...
                        }
                        timeSeriesComplexity.push(timeSeriesComplexityEntry)
                    }
                }

                // prepare churn data for chart
                for (const [key, value] of Object.entries(commit_metrics[i].churn)) {
                    if (key.includes(fileResultPrefixFull)) {

                        const matchingKey = key.replace(fileResultPrefix + "/", "").toLowerCase()
                        if (Object.keys(selectedNodesMap).length > 0) {
                            if ((matchingKey in selectedNodesMap) == false) {
                                continue
                            }
                        }

                        let timeSeriesChurnEntry = {
                            'filepath' : key,
                            'churn' : value,
                            'date': commit_metrics[i].exact_date.replace(/_/g, "-") // TODO ...
                        }
                        timeSeriesChurn.push(timeSeriesChurnEntry)
                    }
                }
            }
            
            let complexityChart = LineChart(timeSeriesComplexity, {
                x: d => Date.parse(d.date),
                y: d => d.wscomplexity,
                z: d => d.filepath,
                yLabel: "Whitespace Complexity",
                width: 900,
                height: 350,
                color: "lightsteelblue",
                voronoi: false,
                id: "timeSeriesComplexityChart"
            })

            let churnChart = LineChart(timeSeriesChurn, {
                x: d => Date.parse(d.date),
                y: d => d.churn,
                z: d => d.filepath,
                yLabel: "Code churn",
                width: 900,
                height: 350,
                color: "lightsteelblue",
                voronoi: false,
                id: "timeSeriesChurnChart"
            })

            document.getElementById("my_dataviz").appendChild(complexityChart);
            document.getElementById("my_dataviz2").appendChild(churnChart);
        }

        function generateChangeCouplingChart() {

            let flows = []
            let locations = []
            let locationId = 0

            let locationColorMap = {}
            
            for (let i = gitMetricsIndexFrom; i < gitMetricsIndexTo; i++) {

                // prepare change coupling data for chart
                if (commit_metrics[i].links.length > 0) {
                    
                    for (link of commit_metrics[i].links) {
                        
                        const matchingSourceKey = link.source
                        const matchingTargetKey = link.target

                        if ( !(locations.find(e => e.name === matchingSourceKey)) ) {

                            if ( !(matchingSourceKey in locationColorMap) ) {
                                let randomColor = "#000000".replace(/0/g,function(){return (~~(Math.random()*16)).toString(16);});
                                locationColorMap[matchingSourceKey] = randomColor
                            }

                            let location = {
                                'id': locationId,
                                'name': matchingSourceKey,
                                'color': locationColorMap[matchingSourceKey]
                            }
                            locations.push(location)
                            
                            let flow = {
                                'from' : locationId,
                                'to' : locationId,
                                'quantity': 0
                                
                            }
                            flows.push(flow)
                            locationId += 1
                        }
                        
                        if ( !(locations.find(e => e.name === matchingTargetKey)) ) {

                            if ( !(matchingTargetKey in locationColorMap) ) {
                                let randomColor = "#000000".replace(/0/g,function(){return (~~(Math.random()*16)).toString(16);});
                                locationColorMap[matchingTargetKey] = randomColor
                            }

                            let location = {
                                'id': locationId,
                                'name': matchingTargetKey,
                                'color': locationColorMap[matchingTargetKey]
                            }
                            
                            locations.push(location)
                            let flow = {
                                'from' : locationId,
                                'to' : locationId,
                                'quantity': 0
                                
                            }
                            flows.push(flow)
                            locationId += 1
                        }
                        
                        const iSource = locations.findIndex(e => e.name === matchingSourceKey);
                        const iTarget = locations.findIndex(e => e.name === matchingTargetKey);
                        
                        if (iSource > -1 && iTarget > -1) {
                            let flow = {
                                'from' : locations[iSource].id,
                                'to' : locations[iTarget].id,
                                'quantity': 15
                            }
                            flows.push(flow)
                        }                            
                        
                    }
                    
                }
                
            }

            for (let n = 0; n < locationId; n++) {
                for (let m = 0; m < locationId; m++) {
                    if ( !(flows.find(e => e.from === n && e.to === m )) ) {
                        let flow = {
                            'from' : n,
                            'to' : m,
                            'quantity': 0
                        }
                        flows.push(flow)
                    }
                }
            }


            // Borrowed from this great blog entry:
            // https://blog.noser.com/d3-js-chord-diagramm-teil-2-benutzerdefinierte-sortierung-und-kurvenformen/
            
            var matrix = [];
            
            //Map list of data to matrix
            flows.forEach(function (flow) {
                
                //Initialize sub-array if not yet exists
                if (!matrix[flow.to]) {
                    matrix[flow.to] = [];
                }
                
                matrix[flow.to][flow.from] = flow.quantity;
            });
            
            /*//////////////////////////////////////////////////////////
            /////////////// Initiate Chord Diagram /////////////////////
            //////////////////////////////////////////////////////////*/
            let size = 1000;
            let dr = 40; //radial translation for group names
            let dx = 20; //horizontal translation for group names
            let margin = { top: 0, right: 70, bottom: 70, left: 70 };
            let chordWidth = size - margin.left - margin.right;
            let chordHeight = size - margin.top - margin.bottom;
            let innerRadius = Math.min(chordWidth, chordHeight) * .39;
            let outerRadius = innerRadius * 1.08;
            
            let root = d3.select("#change_coupling_chord_diagram");
            
            //Generate tooltip already, but keep it invisible for now.
            var toolTip = root.append("div")
            .classed("tooltip", true)
            .style("opacity", 0)
            .style("position", "absolute")
            .style("text-align", "center")
            .style("padding", "6px")
            .style("font", "12px sans-serif")
            .style("color", "black")
            .style("background", "silver")
            .style("border", "1px solid gray")
            .style("border-radius", "8px")
            .style("pointer-events", "none");
            
            var focusedChordGroupIndex = null;
            
            /*Initiate the SVG*/
            //D3.js v3!
            var svg = root.append("svg:svg")
            .attr("width", chordWidth + margin.left + margin.right)
            .attr("height", chordHeight + margin.top + margin.bottom)
            .attr("id", "svg_change_coupling_chord_diagram");
            
            var container = svg.append("g")
            .attr("transform", "translate(" + 
            (margin.left + chordWidth / 2) + "," + 
            (margin.top + chordHeight / 2) + ")");
            
            var chord = customChordLayout()
            .padding(0.04)
            .sortSubgroups(d3.descending) /*sort the chords inside an arc from high to low*/
            .sortChords(d3.ascending) /*which chord should be shown on top when chords cross. Now the largest chord is at the top*/
            .matrix(matrix);
            
            /*//////////////////////////////////////////////////////////
            ////////////////// Draw outer Arcs /////////////////////////
            //////////////////////////////////////////////////////////*/
            var arc = d3.arc()
            .innerRadius(innerRadius)
            .outerRadius(outerRadius);
            
            var g = container.selectAll("g.group")
            .data(chord.groups)
            .enter()
            .append("svg:g")
            .attr("class", function (d) { return "group group-" + locations[d.index].id; });
            
            g.append("svg:path")
            .attr("d", arc)
            .style("fill", function (d) { 
                return locations[d.index].color; 
            })
            .style("stroke", function (d) { 
                return d3.rgb(locations[d.index].color).brighter(); 
            })
            .on("click", function (event, d) { highlightChords(d.index) }) // .on("click", function (d) { highlightChords(d.index) })
            .on("mouseover", function(event, i) { 
                showArcToolTip(event, i);
            })
            .on("mouseout", function(d) { hideToolTip() });
            
            /*//////////////////////////////////////////////////////////
            //////////////// Initiate inner chords /////////////////////
            //////////////////////////////////////////////////////////*/
            var chords = container.selectAll("path.chord")
            .data(chord.chords)
            .enter()
            .append("svg:path")
            .attr("class", function (d) {
                return "chord chord-source-" + d.source.index + " chord-target-" + d.target.index;
            })
            .attr("d", customChordPathGenerator().radius(innerRadius))
            //Change the fill to reference the unique gradient ID
            //of the source-target combination
            .style("fill", function (d) {
                return "url(#chordGradient-" + d.source.index + "-" + d.target.index + ")";
            })
            .style("stroke", function (d) {
                return "url(#chordGradient-" + d.source.index + "-" + d.target.index + ")";
            })
            .style("fill-opacity", "0.7")
            .on("mouseover", function(event, i) { 
                if (focusedChordGroupIndex === null || 
                i.source.index === focusedChordGroupIndex || 
                i.target.index === focusedChordGroupIndex) {
                    if (focusedChordGroupIndex === null) {
                        d3.selectAll(".chord")
                        .style("fill-opacity", 0.2)
                        .style("stroke-opacity", 0.2);
                        d3.select(this).style("fill-opacity", 1);
                    }
                    else {
                        d3.selectAll(".chord.chord-source-" + focusedChordGroupIndex + ", " + 
                        ".chord.chord-target-" + focusedChordGroupIndex)
                        .style("fill-opacity", 0.2)
                        .style("stroke-opacity", 0.2);
                        d3.select(this).style("fill-opacity", 1);
                    }
                    
                    showChordToolTip(event, i);
                }
            })
            .on("mouseout", function(d) { 
                if (focusedChordGroupIndex === null) {
                    d3.selectAll(".chord")
                    .style("fill-opacity", 0.7)
                    .style("stroke-opacity", 1);
                }
                else {
                    d3.selectAll(".chord.chord-source-" + focusedChordGroupIndex + ", " +
                    ".chord.chord-target-" + focusedChordGroupIndex)
                    .style("fill-opacity", 0.7)
                    .style("stroke-opacity", 1);
                }
                
                hideToolTip();
            });
            
            //Cf https://www.visualcinnamon.com/2016/06/orientation-gradient-d3-chord-diagram
            //Create a gradient definition for each chord
            var grads = svg.append("defs").selectAll("linearGradient")
            .data(chord.chords)
            .enter().append("linearGradient")
            //Create a unique gradient id per chord: e.g. "chordGradient-0-4"
            .attr("id", function (d) {
                return "chordGradient-" + d.source.index + "-" + d.target.index;
            })
            //Instead of the object bounding box, use the entire SVG for setting locations
            //in pixel locations instead of percentages (which is more typical)
            .attr("gradientUnits", "userSpaceOnUse")
            //The full mathematical formula to find the x and y locations
            .attr("x1", function (d, i) {
                return innerRadius * Math.cos((d.source.endAngle - d.source.startAngle) / 2 +
                d.source.startAngle - Math.PI / 2);
            })
            .attr("y1", function (d, i) {
                return innerRadius * Math.sin((d.source.endAngle - d.source.startAngle) / 2 +
                d.source.startAngle - Math.PI / 2);
            })
            .attr("x2", function (d, i) {
                return innerRadius * Math.cos((d.target.endAngle - d.target.startAngle) / 2 +
                d.target.startAngle - Math.PI / 2);
            })
            .attr("y2", function (d, i) {
                return innerRadius * Math.sin((d.target.endAngle - d.target.startAngle) / 2 +
                d.target.startAngle - Math.PI / 2);
            });
            
            //Set the starting color (at 0%)
            grads.append("stop")
            .attr("offset", "0%")
            .attr("stop-color", function (d) { return locations[d.source.index].color; });
            
            //Set the ending color (at 100%)
            grads.append("stop")
            .attr("offset", "100%")
            .attr("stop-color", function (d) { return locations[d.target.index].color; });
            
            
            /*//////////////////////////////////////////////////////////
            ////////////////// Initiate Ticks //////////////////////////
            //////////////////////////////////////////////////////////*/
            var ticks = g.append("svg:g")
            .selectAll("g.ticks")
            .data(groupTicks)
            .enter().append("svg:g")
            .attr("transform", function (d) {
                return "rotate(" + (d.angle * 180 / Math.PI - 90) + ")"
                + "translate(" + outerRadius + 40 + ",0)";
            });
            
            /*Append the tick around the arcs*/
            ticks.append("svg:line")
            .attr("x1", 1)
            .attr("y1", 0)
            .attr("x2", 6)
            .attr("y2", 0)
            .attr("class", "ticks")
            .style("stroke", "#FFF")
            .style("stroke-width", "1.5px");
            
            /*Add the labels for the ticks*/
            ticks.append("svg:text")
            .attr("class", "tickLabels")
            .attr("x", 12)
            .attr("dy", ".35em")
            .style("font-size", "10px")
            .style("font-family", "sans-serif")
            .attr("fill", "#FFF")
            .attr("transform", function (d) { 
                return d.angle > Math.PI ? "rotate(180)translate(-25)" : null; 
            })
            .style("text-anchor", function (d) { 
                return d.angle > Math.PI ? "end" : null; 
            })
            .text(function (d) { return d.label; });
            
            /*//////////////////////////////////////////////////////////
            ////////////////// Initiate Names //////////////////////////
            //////////////////////////////////////////////////////////*/
            g.append("svg:text")
            .each(function (d) { d.angle = (d.startAngle + d.endAngle) / 2; })
            .attr("dy", ".35em")
            .attr("class", "titles")
            .style("font-size", "14px")
            .style("font-family", "sans-serif")
            .attr("fill", "#FFF")
            .attr("text-anchor", function (d) { 
                return d.angle > Math.PI ? "end" : null; 
            })
            .attr("transform", function (d) {
                var r = outerRadius + dr;
                var angle = d.angle + ((3 *Math.PI) / 2);
                var x = r * Math.cos(angle);
                var y = r * Math.sin(angle);
                
                if (d.angle > Math.PI) {
                    x -= dx;
                }
                else {
                    x += dx;
                }
                
                return "translate(" + x + ", " + y + ")";
            })
            .text(function (d, i) { return locations[i].name; });
            
            /*Lines from labels to arcs*/
            /*part in radial direction*/
            this.g.append("line")
            .attr("x1", function (d) { 
                return outerRadius * Math.cos(d.angle + ((3 * Math.PI) / 2)); 
            })
            .attr("y1", function (d) { 
                return outerRadius * Math.sin(d.angle + ((3 * Math.PI) / 2)); 
            })
            .attr("x2", function (d) { 
                return (outerRadius + dr) * Math.cos(d.angle + ((3 * Math.PI) / 2)); 
            })
            .attr("y2", function (d) { 
                return (outerRadius + dr) * Math.sin(d.angle + ((3 * Math.PI) / 2)); 
            })
            .style("stroke", "#FFF")
            .style("stroke-width", "0.5px");
            
            /*horizontal part*/
            this.g.append("line")
            .attr("x1", function (d) { 
                return (outerRadius + dr) * Math.cos(d.angle + ((3 * Math.PI) / 2)); 
            })
            .attr("y1", function (d) { 
                return (outerRadius + dr) * Math.sin(d.angle + ((3 * Math.PI) / 2)); 
            })
            .attr("x2", function (d) {
                var x = (outerRadius + dr) * Math.cos(d.angle + ((3 * Math.PI) / 2));
                if (d.angle > Math.PI) {
                    x -= dx - 5;
                }
                else {
                    x += dx - 5;
                }
                return x;
            })
            .attr("y2", function (d) { 
                return (outerRadius + dr) * Math.sin(d.angle + ((3 * Math.PI) / 2)); 
            })
            .style("stroke", "#FFF")
            .style("stroke-width", "0.5px");
            
            /*//////////////////////////////////////////////////////////
            ////////////////// Extra Functions /////////////////////////
            //////////////////////////////////////////////////////////*/
            
            /*Returns an array of tick angles and labels, given a group*/
            function groupTicks(d) {
                var anglePerPerson = (d.endAngle - d.startAngle) / d.value;
                return d3.range(0, d.value, 100).map(function (v, i) {
                    return {
                        angle: v * anglePerPerson + d.startAngle,
                        label: i % 5 ? null : v //Each 5th tick has a label
                    };
                });
            };
            
            //Hides all chords except the chords connecting to the subgroup / 
            //location of the given index.
            function highlightChords(index) {
                //If this subgroup is already highlighted, toggle all chords back on.
                if (focusedChordGroupIndex === index) {
                    showAllChords();
                    return;
                }
                
                hideAllChords();
                
                //Show only the ones with source or target == index
                d3.selectAll(".chord-source-" + index + ", .chord-target-" + index)
                .transition().duration(500)
                .style("fill-opacity", "0.7")
                .style("stroke-opacity", "1");
                
                focusedChordGroupIndex = index;
            };
            
            function showAllChords() {
                svg.selectAll("path.chord")
                .transition().duration(500)
                .style("fill-opacity", "0.7")
                .style("stroke-opacity", "1");
                
                focusedChordGroupIndex = null;
            };
            
            function hideAllChords() {
                svg.selectAll("path.chord")
                .transition().duration(500)
                .style("fill-opacity", "0")
                .style("stroke-opacity", "0");
            };
            
            function showChordToolTip(event, chord) {
                var prompt = "";
                
                if (chord.source.index !== chord.target.index) {
                    prompt += chord.source.value + " Kunden gingen von " + 
                    locations[chord.target.index].name + " nach " + 
                    locations[chord.source.index].name + ".";
                    prompt += "<br>";
                    prompt += chord.target.value + " Kunden gingen von " + 
                    locations[chord.source.index].name + " nach " + 
                    locations[chord.target.index].name + ".";
                }
                else {
                    prompt += chord.source.value + " Kunden blieben in " + 
                    locations[chord.source.index].name + ".";
                }
                
                // TODO
                const[x, y] = d3.pointer(event);
                // console.log(x)
                // console.log(y)

                toolTip
                .style("opacity", 1)
                .html(prompt)
                .style("left", x - toolTip.node().getBoundingClientRect().width / 2 + "px") // .style("left", d3.event.pageX - toolTip.node().getBoundingClientRect().width / 2 + "px")
                .style("top", (y - 50) + "px"); // .style("top", (d3.event.pageY - 50) + "px");
            };
            
            function showArcToolTip(event, arc) {
                const[x, y] = d3.pointer(event);
                // console.log(locations)
                // console.log(arc)

                var prompt = Math.round(arc.value) + " Kunden befinden sich in " + locations[arc.index].name + ".";
                
                toolTip
                .style("opacity", 1)
                .html(prompt)
                .style("left", x - toolTip.node().getBoundingClientRect().width / 2 + "px")
                .style("top", (y - 30) + "px");
            };
            
            function hideToolTip() {
                toolTip.style("opacity", 0);
            };
            
            ////////////////////////////////////////////////////////////
            //////////// Custom Chord Layout Function //////////////////
            /////// Places the Chords in the visually best order ///////
            ///////////////// to reduce overlap ////////////////////////
            ////////////////////////////////////////////////////////////
            //////// Slightly adjusted by Nadieh Bremer ////////////////
            //////////////// VisualCinnamon.com ////////////////////////
            ////////////////////////////////////////////////////////////
            ////// Original from the d3.layout.chord() function ////////
            ///////////////// from the d3.js library ///////////////////
            //////////////// Created by Mike Bostock ///////////////////
            ////////////////////////////////////////////////////////////
            function customChordLayout() {
                var ε = 1e-6, ε2 = ε * ε, π = Math.PI, τ = 2 * π, τε = τ - ε, halfπ = π / 2, d3_radians = π / 180, d3_degrees = 180 / π;
                var chord = {}, chords, groups, matrix, n, padding = 0, sortGroups, sortSubgroups, sortChords;
                function relayout() {
                    var subgroups = {}, groupSums = [], groupIndex = d3.range(n), subgroupIndex = [], k, x, x0, i, j;
                    var numSeq;
                    chords = [];
                    groups = [];
                    k = 0, i = -1;
                    
                    while (++i < n) {
                        x = 0, j = -1, numSeq = [];
                        while (++j < n) {
                            x += matrix[i][j];
                        }
                        groupSums.push(x);
                        //////////////////////////////////////
                        ////////////// New part //////////////
                        //////////////////////////////////////
                        for (var m = 0; m < n; m++) {
                            numSeq[m] = (n + (i - 1) - m) % n;
                        }
                        subgroupIndex.push(numSeq);
                        //////////////////////////////////////
                        //////////  End new part /////////////
                        //////////////////////////////////////
                        k += x;
                    }//while
                    
                    k = (τ - padding * n) / k;
                    x = 0, i = -1;
                    while (++i < n) {
                        x0 = x, j = -1;
                        while (++j < n) {
                            var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;
                            subgroups[di + "-" + dj] = {
                                index: di,
                                subindex: dj,
                                startAngle: a0,
                                endAngle: a1,
                                value: v
                            };
                        }//while
                        
                        groups[di] = {
                            index: di,
                            startAngle: x0,
                            endAngle: x,
                            value: (x - x0) / k
                        };
                        x += padding;
                    }//while
                    
                    i = -1;
                    while (++i < n) {
                        j = i - 1;
                        while (++j < n) {
                            var source = subgroups[i + "-" + j], target = subgroups[j + "-" + i];
                            if (source.value || target.value) {
                                chords.push(source.value < target.value ? {
                                    source: target,
                                    target: source
                                } : {
                                    source: source,
                                    target: target
                                });
                            }//if
                        }//while
                    }//while
                    if (sortChords) resort();
                }//function relayout
                
                function resort() {
                    chords.sort(function (a, b) {
                        return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);
                    });
                }
                chord.matrix = function (x) {
                    if (!arguments.length) return matrix;
                    n = (matrix = x) && matrix.length;
                    chords = groups = null;
                    return chord;
                };
                chord.padding = function (x) {
                    if (!arguments.length) return padding;
                    padding = x;
                    chords = groups = null;
                    return chord;
                };
                chord.sortGroups = function (x) {
                    if (!arguments.length) return sortGroups;
                    sortGroups = x;
                    chords = groups = null;
                    return chord;
                };
                chord.sortSubgroups = function (x) {
                    if (!arguments.length) return sortSubgroups;
                    sortSubgroups = x;
                    chords = null;
                    return chord;
                };
                chord.sortChords = function (x) {
                    if (!arguments.length) return sortChords;
                    sortChords = x;
                    if (chords) resort();
                    return chord;
                };
                chord.chords = function () {
                    if (!chords) relayout();
                    return chords;
                };
                chord.groups = function () {
                    if (!groups) relayout();
                    return groups;
                };
                return chord;
            };
            
            ////////////////////////////////////////////////////////////
            //////////// Custom Chord Path Generator ///////////////////
            ///////// Uses cubic bezier curves with quadratic //////////
            /////// spread of control points to minimise overlap ///////
            ////////////////// of adjacent chords. /////////////////////
            ////////////////////////////////////////////////////////////
            /////// Original from the d3.svg.chord() function //////////
            ///////////////// from the d3.js library ///////////////////
            //////////////// Created by Mike Bostock ///////////////////
            ////////////////////////////////////////////////////////////
            function customChordPathGenerator() {
                var source = function(d) { return d.source; };
                var target = function(d) { return d.target; };
                var radius = function(d) { return d.radius; };
                var startAngle = function(d) { return d.startAngle; };
                var endAngle = function(d) { return d.endAngle; };
                
                function chord(d, i) {
                    var s = subgroup(this, source, d, i),
                    t = subgroup(this, target, d, i);
                    
                    var path = "M" + s.p0
                    + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t)
                    ? curve(s.r, s.p1, s.a1, s.r, s.p0, s.a0)
                    : curve(s.r, s.p1, s.a1, t.r, t.p0, t.a0)
                    + arc(t.r, t.p1, t.a1 - t.a0)
                    + curve(t.r, t.p1, t.a1, s.r, s.p0, s.a0))
                    + "Z";
                    
                    return path;
                }
                
                function subgroup(self, f, d, i) {
                    var subgroup = f.call(self, d, i),
                    r = radius.call(self, subgroup, i),
                    a0 = startAngle.call(self, subgroup, i) - (Math.PI / 2),
                    a1 = endAngle.call(self, subgroup, i) - (Math.PI / 2);
                    
                    return {
                        r: r,
                        a0: a0,
                        a1: a1,
                        p0: [r * Math.cos(a0), r * Math.sin(a0)],
                        p1: [r * Math.cos(a1), r * Math.sin(a1)]
                    };
                }
                
                function equals(a, b) {
                    return a.a0 == b.a0 && a.a1 == b.a1;
                }
                
                function arc(r, p, a) {
                    return "A" + r + "," + r + " 0 " + +(a > Math.PI) + ",1 " + p;
                }
                
                function curve(r0, p0, a0, r1, p1, a1) {
                    var deltaAngle = Math.abs(mod((a1 - a0 + Math.PI), (2 * Math.PI)) - Math.PI);
                    var radialControlPointScale = Math.pow((Math.PI - deltaAngle) / Math.PI, 2) * 0.9;
                    var controlPoint1 = [p0[0] * radialControlPointScale, p0[1] * radialControlPointScale];
                    var controlPoint2 = [p1[0] * radialControlPointScale, p1[1] * radialControlPointScale];
                    var cubicBezierSvg = "C " + controlPoint1[0] + " " + controlPoint1[1] + ", " + 
                    controlPoint2[0] + " " + controlPoint2[1] + ", " + 
                    p1[0] + " " + p1[1];
                    return cubicBezierSvg;
                }
                
                function mod(a, n) {
                    return (a % n + n) % n;
                }
                
                chord.radius = function(v) {
                    if (!arguments.length) return radius;
                    radius = typeof v === "function" ? v : function() { return v; };
                    return chord;
                };
                
                chord.source = function(v) {
                    if (!arguments.length) return source;
                    source = typeof v === "function" ? v : function() { return v; };
                    return chord;
                };
                
                chord.target = function(v) {
                    if (!arguments.length) return target;
                    target = typeof v === "function" ? v : function() { return v; };
                    return chord;
                };
                
                chord.startAngle = function(v) {
                    if (!arguments.length) return startAngle;
                    startAngle = typeof v === "function" ? v : function() { return v; };
                    return chord;
                };
                
                chord.endAngle = function(v) {
                    if (!arguments.length) return endAngle;
                    endAngle = typeof v === "function" ? v : function() { return v; };
                    return chord;
                };
                
                return chord;
            }
            
        }

    </script>

</body>