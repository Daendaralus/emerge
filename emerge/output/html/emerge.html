
<!DOCTYPE html>
<meta charset="utf-8">

<head>
    <!-- bootstrap css v5.2.3 -->
    <link rel="stylesheet" type="text/css" href="vendors/bootstrap/css/bootstrap.css">

    <link rel="stylesheet" type="text/css" href="resources/css/custom.css" />

    <!-- dark-mode-switch css -->
    <link rel="stylesheet" href="vendors/dark-mode-switch/css/dark-mode.css">

    <!-- jquery js -->
    <script type="text/javascript" src="vendors/jquery/jquery-3.6.0.min.js"></script>
    <!-- popperjs/core v2.11.6 -->
    <script type="text/javascript" src="vendors/popper/popper.min.js"></script>
    <!-- bootstrap js v5.2.3 -->
    <script type="text/javascript" src="vendors/bootstrap/js/bootstrap.min.js"></script>

    <!-- daterange picker | https://github.com/dangrossman/daterangepicker -->
    <script type="text/javascript" src="vendors/daterangepicker/moment.min.js"></script>
    <script type="text/javascript" src="vendors/daterangepicker/daterangepicker.min.js"></script>
    <link rel="stylesheet" type="text/css" href="vendors/daterangepicker/daterangepicker.css"/>

    <!-- d3 js -->
    <script src="vendors/d3/d3.v7.8.4.min.js"></script>

    <!-- Hull.js -->
    <script type="text/javascript" src="vendors/hull/hull.js"></script>
    <!-- simpleheat.hs -->
    <script type="text/javascript" src="vendors/simpleheat/simpleheat.js"></script>
    <!-- exported graph representations as js -->
    <script type="text/javascript" src="resources/js/graph_representations_d3_force_graph.js"></script>

    <style>
        div.graphDiv {
            width: 100%;
        }

        body {
            overflow-y: hidden;
            overflow-x: hidden;
        }

        .card-body {
            padding-top: 4px;
            padding-bottom: 12px;
        }
        
        .tooltip-inner {
            background-color: white;
            color: black;
            font-size: smaller;
            text-align: left;
        }

        .wide-tooltip .tooltip-inner {
            min-width: 340px;
        }
        
        .bs-tooltip-bottom {
            margin-top: 6px;
        }

        hr {
            margin-top: 1rem;
            margin-bottom: 1rem;
            border: 0;
            border-top: 2px solid #0d6efd;
        }

        .btn {
            padding: 2px;
        }

        .btn-left-aligned {
            text-align: left !important;
            padding-left: 10px;
        }

        .btn-right-aligned {
            text-align: right !important;
            padding-right: 10px;
        }

        #projectNameListElement {
            padding-bottom: 1px;
            padding-top: 2px;
        }

        #analysisNameListElement {
            padding-bottom: 1px;
            padding-top: 1px;
        }

        #analysisDateTimeListElement {
            padding-top: 1px;
            padding-bottom: 4px;
        }

        #graphDiv {
            position: relative;
        }
        
        #inputNodeSearchLabel,
        #selectNodesLabel,
        #resetSelectionLabel,
        #expandSelectionLabel,
        #hoverSelectionLabel,
        #fadeUnselectedNodesLabel {
            font-size: 10px;
            margin-bottom: 2px;
            padding-top: 4px;
        }
        
        #cardMenu {
            position: absolute;
            top: 6px;
            right: 5px;
            width: 200px;
        }
        
        #menuButtonGroup {
            padding-left: 0px;
            padding-top: 6px;
            padding-bottom: 0px;
        }
        
        #dropdown-apply-metric {
            min-width: 200px;
        }

        .list-group {
            --bs-list-group-color: #212529;
            --bs-list-group-bg: #fff;
            --bs-list-group-border-color: rgba(0, 0, 0, 0.125);
            --bs-list-group-border-width: 1px;
            --bs-list-group-border-radius: 0.375rem;
            --bs-list-group-item-padding-x: 0.2rem;
            --bs-list-group-item-padding-y: 0.2rem;
            --bs-list-group-action-color: #495057;
            --bs-list-group-action-hover-color: #495057;
            --bs-list-group-action-hover-bg: #f8f9fa;
            --bs-list-group-action-active-color: #212529;
            --bs-list-group-action-active-bg: #e9ecef;
            --bs-list-group-disabled-color: #6c757d;
            --bs-list-group-disabled-bg: #fff;
            --bs-list-group-active-color: #fff;
            --bs-list-group-active-bg: #0d6efd;
            --bs-list-group-active-border-color: #0d6efd;
            display: flex;
            flex-direction: column;
            padding-left: 0;
            margin-bottom: 0;
            border-radius: var(--bs-list-group-border-radius);
        }

    </style>
</head>

<body>
    <div id="graphDiv"></div>

    <div id="cardMenu" class="card border-dark">
        <h6 class="card-header align-items-center text-center">
            <span aria-hidden="true">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-bounding-box-circles" viewBox="0 0 16 16">
                    <path d="M2 1a1 1 0 1 0 0 2 1 1 0 0 0 0-2zM0 2a2 2 0 0 1 3.937-.5h8.126A2 2 0 1 1 14.5 3.937v8.126a2 2 0 1 1-2.437 2.437H3.937A2 2 0 1 1 1.5 12.063V3.937A2 2 0 0 1 0 2zm2.5 1.937v8.126c.703.18 1.256.734 1.437 1.437h8.126a2.004 2.004 0 0 1 1.437-1.437V3.937A2.004 2.004 0 0 1 12.063 2.5H3.937A2.004 2.004 0 0 1 2.5 3.937zM14 1a1 1 0 1 0 0 2 1 1 0 0 0 0-2zM2 13a1 1 0 1 0 0 2 1 1 0 0 0 0-2zm12 0a1 1 0 1 0 0 2 1 1 0 0 0 0-2z"/>
                </svg>                
                <span>
                    <small> <strong><span id="configEmergeVersion" style="padding-left: 2px;"></span></strong></small>
                </span>
            </span>
        </h6>

        <div class="card-body">
            <ul class="list-group list-group-flush">
                <li class="list-group-item small d-flex justify-content-between align-items-center py-1">
                
                    <div class="form-check form-switch float-right"> 
                        <input type="checkbox" class="form-check-input" id="darkSwitch">
                        <label class="form-check-label" for="darkSwitch"><small>Dark Mode</small></label>
                    </div>

                </li>

                <li class="list-group-item small d-flex justify-content-between align-items-center medium-tooltip">
                    <small><span id="projectInfo">Project info</span></small> <span id="badge_project_info" data-bs-toggle="tooltip" data-bs-placement="bottom" data-bs-html="true" class="badge rounded-pill text-bg-primary"> ?</span></span>
                </li>

                <li class="list-group-item small d-flex justify-content-between align-items-center">
                    <small><span id="graphProperties">Graph properties</span></small> <span id="badge_graph_info" data-bs-toggle="tooltip" data-bs-placement="bottom" data-bs-html="true" class="badge rounded-pill text-bg-primary"> ?</span></span>
                </li>


<!-- 
                <li id="projectNameListElement" class="list-group-item small d-flex justify-content-between align-items-center">
                    <small><span id="configProjectName">project</span></small>
                </li>

                <li id="analysisNameListElement" class="list-group-item small d-flex justify-content-between align-items-center">
                    <small><span id="analysisName"></span></small>
                </li>

                <li id="analysisDateTimeListElement" class="list-group-item small d-flex justify-content-between align-items-center">
                    <small><span id="configAnalysisDateTime">bar</span></small>
                </li>

                <li class="list-group-item small d-flex justify-content-between align-items-center disabled py-1">
                    <small>Graph properties</small>
                </li> -->


                <!-- <li class="list-group-item small d-flex justify-content-between align-items-center py-1">
                    <small>Nodes</small>
                    <span class="badge badge-primary badge-pill" id="numberNodes">0</span>
                </li>
                <li class="list-group-item small d-flex justify-content-between align-items-center py-1">
                    <small>Edges</small>
                    <span class="badge badge-primary badge-pill" id="numberEdges">0</span>
                </li>
                <li class="list-group-item small d-flex justify-content-between align-items-center py-1">
                    <small>Charge force</small>
                    <span class="badge badge-primary badge-pill" id="chargeForce">0</span>
                </li> -->


            </ul>

            <div id="menuButtonGroup" class="btn-group-vertical" style="min-width: 80px;">
                <div class="btn-group">
                     
                    <button type="button" class="btn btn-primary btn-sm dropdown-toggle btn-with-spacing shadow-none" id="selectGraphButton" data-bs-toggle="dropdown">
                        <span id="selectedGraph">selected graph</span>
                    </button>

                    <div class="dropdown-menu" id="dropdown-graph" aria-labelledby="dropdown-graph">
                        <!-- injected by JS -->
                    </div>

                </div>

                <button type="button" class="btn-left-aligned btn btn-primary btn-sm btn-with-spacing shadow-none" onclick="toggleNodeLabels();">
                <span aria-hidden="true">
                    <svg width="16px" height="16px" viewBox="0 0 18 18" class="bi bi-info-circle" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                        <path fill-rule="evenodd" d="M8 15A7 7 0 1 0 8 1a7 7 0 0 0 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>
                        <path d="M8.93 6.588l-2.29.287-.082.38.45.083c.294.07.352.176.288.469l-.738 3.468c-.194.897.105 1.319.808 1.319.545 0 1.178-.252 1.465-.598l.088-.416c-.2.176-.492.246-.686.246-.275 0-.375-.193-.304-.533L8.93 6.588z"/>
                        <circle cx="8" cy="4.5" r="1"/>
                    </svg>
                </span>
                Toggle node labels
            </button>

                <div class="btn-group" role="group" aria-label="Basic example">
                    <button type="button" class="btn-left-aligned btn btn-primary btn-sm btn-with-spacing btn-with-spacing-right shadow-none" onclick="decreaseCurrentChargeForce();">
                    <span aria-hidden="true">
                        <svg width="16px" height="16px" viewBox="0 0 18 18" class="bi bi-minus-circle" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                            <path fill-rule="evenodd" d="M8 15A7 7 0 1 0 8 1a7 7 0 0 0 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>
                            <path fill-rule="evenodd" d="M5.5 8a.5.5 0 0 1 .5-.5h4a.5.5 0 0 1 0 1H6a.5.5 0 0 1-.5-.5z"/>
                        </svg>
                    </span>
                    force
                </button>
                    <button type="button" class="btn-right-aligned btn btn-primary btn-sm btn-with-spacing btn-with-spacing-left shadow-none" onclick="increaseCurrentChargeForce();">
                    <span aria-hidden="true">
                        <svg width="16px" height="16px" viewBox="0 0 18 18" class="bi bi-plus-circle" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                            <path fill-rule="evenodd" d="M8 15A7 7 0 1 0 8 1a7 7 0 0 0 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>
                            <path fill-rule="evenodd" d="M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z"/>
                        </svg>
                    </span>
                    force
                </button>
                </div>

                <div class="btn-group" role="group" aria-label="Basic example">
                    <button type="button" class="btn-left-aligned btn btn-primary btn-sm btn-with-spacing btn-with-spacing-right shadow-none" onclick="zoomOut();">
                        <span aria-hidden="true">
                            <svg width="16px" height="16px" viewBox="0 0 18 18" class="bi bi-zoom-out" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                                <path fill-rule="evenodd" d="M6.5 12a5.5 5.5 0 1 0 0-11 5.5 5.5 0 0 0 0 11zM13 6.5a6.5 6.5 0 1 1-13 0 6.5 6.5 0 0 1 13 0z"/>
                                <path d="M10.344 11.742c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1 6.538 6.538 0 0 1-1.398 1.4z"/>
                                <path fill-rule="evenodd" d="M3 6.5a.5.5 0 0 1 .5-.5h6a.5.5 0 0 1 0 1h-6a.5.5 0 0 1-.5-.5z"/>
                            </svg>
                        </span>
                        zoom
                    </button>

                    <button type="button" class="btn-right-aligned btn btn-primary btn-sm btn-with-spacing btn-with-spacing-left shadow-none" onclick="zoomIn();">
                    <span aria-hidden="true">
                    <svg width="16px" height="16px" viewBox="0 0 18 18" class="bi bi-zoom-in" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                        <path fill-rule="evenodd" d="M6.5 12a5.5 5.5 0 1 0 0-11 5.5 5.5 0 0 0 0 11zM13 6.5a6.5 6.5 0 1 1-13 0 6.5 6.5 0 0 1 13 0z"/>
                        <path d="M10.344 11.742c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1 6.538 6.538 0 0 1-1.398 1.4z"/>
                        <path fill-rule="evenodd" d="M6.5 3a.5.5 0 0 1 .5.5V6h2.5a.5.5 0 0 1 0 1H7v2.5a.5.5 0 0 1-1 0V7H3.5a.5.5 0 0 1 0-1H6V3.5a.5.5 0 0 1 .5-.5z"/>
                    </svg>
                    </span>
                    zoom
                    </button>
                </div>

                <button type="button" class="btn btn-primary btn-sm btn-with-spacing shadow-none" onclick="translateCanvas('up')">
                <span aria-hidden="true">
                    <svg width="16px" height="16px" viewBox="0 0 18 18" class="bi bi-arrow-up-circle" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                        <path fill-rule="evenodd" d="M8 15A7 7 0 1 0 8 1a7 7 0 0 0 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>
                        <path fill-rule="evenodd" d="M8 12a.5.5 0 0 0 .5-.5V5.707l2.146 2.147a.5.5 0 0 0 .708-.708l-3-3a.5.5 0 0 0-.708 0l-3 3a.5.5 0 1 0 .708.708L7.5 5.707V11.5a.5.5 0 0 0 .5.5z"/>
                    </svg>
                </span>
            </button>
                <div class="btn-group" role="group" aria-label="Basic example">
                    <button type="button" class="btn btn-primary btn-sm btn-with-spacing btn-with-spacing-right shadow-none" onclick="translateCanvas('left')">
                    <span aria-hidden="true">
                        <svg width="16px" height="16px" viewBox="0 0 18 18" class="bi bi-arrow-left-circle" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                            <path fill-rule="evenodd" d="M8 15A7 7 0 1 0 8 1a7 7 0 0 0 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>
                            <path fill-rule="evenodd" d="M12 8a.5.5 0 0 1-.5.5H5.707l2.147 2.146a.5.5 0 0 1-.708.708l-3-3a.5.5 0 0 1 0-.708l3-3a.5.5 0 1 1 .708.708L5.707 7.5H11.5a.5.5 0 0 1 .5.5z"/>
                        </svg>
                    </span>
                </button>
                    <button type="button" class="btn btn-primary btn-sm btn-with-spacing btn-with-spacing-left  shadow-none" onclick="translateCanvas('right')">
                    <span aria-hidden="true">
                        <svg width="16px" height="16px" viewBox="0 0 18 18" class="bi bi-arrow-right-circle" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                            <path fill-rule="evenodd" d="M8 15A7 7 0 1 0 8 1a7 7 0 0 0 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>
                            <path fill-rule="evenodd" d="M4 8a.5.5 0 0 0 .5.5h5.793l-2.147 2.146a.5.5 0 0 0 .708.708l3-3a.5.5 0 0 0 0-.708l-3-3a.5.5 0 1 0-.708.708L10.293 7.5H4.5A.5.5 0 0 0 4 8z"/>
                        </svg>
                    </span>
                </button>
                </div>
                <button type="button" class="btn btn-primary btn-sm btn-with-spacing shadow-none" onclick="translateCanvas('down')">
                <span aria-hidden="true">
                    <svg width="16px" height="16px" viewBox="0 0 18 18" class="bi bi-arrow-down-circle" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                        <path fill-rule="evenodd" d="M8 15A7 7 0 1 0 8 1a7 7 0 0 0 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>
                        <path fill-rule="evenodd" d="M8 4a.5.5 0 0 1 .5.5v5.793l2.146-2.147a.5.5 0 0 1 .708.708l-3 3a.5.5 0 0 1-.708 0l-3-3a.5.5 0 1 1 .708-.708L7.5 10.293V4.5A.5.5 0 0 1 8 4z"/>
                    </svg>
                </span>
            </button>
                <button id="buttonShowOverallStatistics" type="button" class="btn-left-aligned btn btn-primary btn-sm btn-with-spacing shadow-none" data-bs-toggle="modal" data-bs-target="#overallStatisticsModal">
                <span aria-hidden="true">
                    <svg width="16px" height="16px" viewBox="0 0 18 18" class="bi bi-graph-up" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                        <path fill-rule="evenodd" d="M0 0h1v15h15v1H0V0zm10 3.5a.5.5 0 0 1 .5-.5h4a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-1 0V4.9l-3.613 4.417a.5.5 0 0 1-.74.037L7.06 6.767l-3.656 5.027a.5.5 0 0 1-.808-.588l4-5.5a.5.5 0 0 1 .758-.06l2.609 2.61L13.445 4H10.5a.5.5 0 0 1-.5-.5z"/>
                    </svg>
                </span>
                Overall statistics
            </button>
                <!-- Modal -->
                <div class="modal fade" id="overallStatisticsModal" tabindex="-1" role="dialog" aria-labelledby="overallStatisticsModalLabel" aria-hidden="true">
                    <div class="modal-dialog" role="document">
                        <div class="modal-content">
                            <div class="modal-header">
                                <h5 class="modal-title" id="overallStatisticsModalLabel">Overall statistics</h5>
                                <button type="button" class="close" data-bs-dismiss="modal" aria-label="Close">
                            <span aria-hidden="true">&times;</span>
                            </button>
                            </div>
                            <div class="modal-body">
                                <table class="card-table table table-condensed">
                                    <thead class="table-borderless">
                                        <tr>
                                            <th scope="col">Statistic</th>
                                            <th scope="col">Value</th>
                                        </tr>
                                    </thead>
                                    <tbody id="tbody-statistics">
                                        <!-- injected by js -->
                                    </tbody>
                                </table>
                            </div>
                            <div class="modal-footer">
                                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                            </div>
                        </div>
                    </div>
                </div>
                <!-- end modal -->

                <button type="button" id="buttonShowOverallMetrics" class="btn-left-aligned btn btn-primary btn-sm btn-with-spacing shadow-none" data-bs-toggle="modal" data-bs-target="#overallMetricsModal">
                    <span aria-hidden="true">
                        <svg width="16px" height="16px" viewBox="0 0 18 18" class="bi bi-graph-up" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                            <path fill-rule="evenodd" d="M0 0h1v15h15v1H0V0zm10 3.5a.5.5 0 0 1 .5-.5h4a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-1 0V4.9l-3.613 4.417a.5.5 0 0 1-.74.037L7.06 6.767l-3.656 5.027a.5.5 0 0 1-.808-.588l4-5.5a.5.5 0 0 1 .758-.06l2.609 2.61L13.445 4H10.5a.5.5 0 0 1-.5-.5z"/>
                        </svg>
                    </span>
                    Overall metrics
                </button>

                <div class="btn-group">
                    <button type="button" class="btn btn-primary btn-sm dropdown-toggle btn-with-spacing" data-bs-toggle="dropdown"><span></span> <span class="caret"></span>Apply metrics</button>
                    <ul id="dropdown-apply-metric" class="dropdown-menu">
                        <!-- injected by js -->
                    </ul>
                </div>

                <div style="width: 100%; padding-top: 4px; padding-bottom: 0px;"></div>

                <ul class="list-group list-group-flush">

                <!-- Shortcuts -->
                <li class="list-group-item small d-flex justify-content-between align-items-center" style="border: 0px; margin-bottom: 0px; padding-left: 0px;">
                      <label style="margin-bottom: 0px; padding-right: 4px;"> <small>Shortcuts</small> </label> <span id="badge_shortcuts" data-bs-toggle="tooltip" data-bs-placement="bottom" data-bs-html="true" class="badge rounded-pill text-bg-primary" customClass="large-tooltip"> ?</span>
                </li>

                <li id="li-unselected-opacity" class="list-group-item small d-flex justify-content-between align-items-center py-1" style="border: 0px; margin-bottom: 0px; padding-left: 0px; padding-bottom: 0px;">
                    <small>Unselected opacity</small> <span id="badge_unselected_opacity" style="margin-left: 4px;" data-bs-toggle="tooltip" data-bs-placement="bottom" data-bs-html="true" class="badge rounded-pill text-bg-primary"> ?</span>
                </li>
                <input type="range" min="1" max="100" value="20" class="form-range" id="unselected-opacity" oninput="unselectedOpacityChange(this.value)" onchange="unselectedOpacityChange(this.value)">

                <!-- Git settings -->
                <div style="width: 100%; padding-top: 4px; padding-bottom: 0px;"></div>
                <li class="list-group-item small d-flex justify-content-between align-items-center py-1 disabled" style="max-height: 24px; border: 0px; margin-bottom: 0px; padding-left: 0px;">
                    <small style="font-size: 10px;">Git settings </small>
                    <div class="form-group" style="width: 50%;">
                        <hr>
                    </div>
                </li>

                <div class="input-group mb-1 input-group-sm">
                <input class="form-control form-control-sm" type="text" name="daterange" placeholder="pick date range" id="timeDateRangePicker" style="font-size: 9px;" />
                <button class="btn btn-primary " type="button" id="inputDateRangePickerCancel" onclick="clickDateRangePickerCancel()">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-bootstrap-reboot" viewBox="0 0 16 16">
                        <path d="M1.161 8a6.84 6.84 0 1 0 6.842-6.84.58.58 0 1 1 0-1.16 8 8 0 1 1-6.556 3.412l-.663-.577a.58.58 0 0 1 .227-.997l2.52-.69a.58.58 0 0 1 .728.633l-.332 2.592a.58.58 0 0 1-.956.364l-.643-.56A6.812 6.812 0 0 0 1.16 8z"/>
                        <path d="M6.641 11.671V8.843h1.57l1.498 2.828h1.314L9.377 8.665c.897-.3 1.427-1.106 1.427-2.1 0-1.37-.943-2.246-2.456-2.246H5.5v7.352h1.141zm0-3.75V5.277h1.57c.881 0 1.416.499 1.416 1.32 0 .84-.504 1.324-1.386 1.324h-1.6z"/>
                      </svg>
                </button>
                </div>
            
                <div style="width: 100%; padding-top: 6px; padding-bottom: 0px;"></div>

                <!-- time series modal -->
                <!-- Modal -->
                <div class="modal fade" id="timeSeriesModal" tabindex="-1" aria-labelledby="timeSeriesModalLabel" aria-hidden="true">
                    <div class="modal-dialog modal-xl">
                    <div class="modal-content">
                        <div class="modal-header">
                        <h1 class="modal-title fs-5" id="timeSeriesModalLabel">Modal title</h1>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                        </div>
                        <div class="modal-body">
                        
                        <div id="my_dataviz"></div>

                        </div>
                        <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                        <button type="button" class="btn btn-primary">Save changes</button>
                        </div>
                    </div>
                    </div>
                </div>

                <!-- <button type="button" class="btn-left-aligned btn btn-primary btn-sm btn-with-spacing shadow-none" data-bs-toggle="modal" data-bs-target="#timeSeriesModal" onclick="generateTimeSeriesChart()" >
                    <span aria-hidden="true">
                        <svg width="16px" height="16px" viewBox="0 0 18 18" class="bi bi-graph-up" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                            <path fill-rule="evenodd" d="M0 0h1v15h15v1H0V0zm10 3.5a.5.5 0 0 1 .5-.5h4a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-1 0V4.9l-3.613 4.417a.5.5 0 0 1-.74.037L7.06 6.767l-3.656 5.027a.5.5 0 0 1-.808-.588l4-5.5a.5.5 0 0 1 .758-.06l2.609 2.61L13.445 4H10.5a.5.5 0 0 1-.5-.5z"/>
                        </svg>
                    </span>
                    Churn time series
                </button>

                <button type="button" class="btn-left-aligned btn btn-primary btn-sm btn-with-spacing shadow-none" data-bs-toggle="modal" data-bs-target="#timeSeriesModal" onclick="generateTimeSeriesChart()" >
                    <span aria-hidden="true">
                        <svg width="16px" height="16px" viewBox="0 0 18 18" class="bi bi-graph-up" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                            <path fill-rule="evenodd" d="M0 0h1v15h15v1H0V0zm10 3.5a.5.5 0 0 1 .5-.5h4a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-1 0V4.9l-3.613 4.417a.5.5 0 0 1-.74.037L7.06 6.767l-3.656 5.027a.5.5 0 0 1-.808-.588l4-5.5a.5.5 0 0 1 .758-.06l2.609 2.61L13.445 4H10.5a.5.5 0 0 1-.5-.5z"/>
                        </svg>
                    </span>
                    Hotspot scatterplot
                </button>

                <button type="button" class="btn-left-aligned btn btn-primary btn-sm btn-with-spacing pl-0 shadow-none text-left" data-bs-toggle="modal" data-bs-target="#timeSeriesModal" onclick="generateTimeSeriesChart()" >
                    <span aria-hidden="true">
                        <svg width="16px" height="16px" viewBox="0 0 18 18" class="bi bi-graph-up" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                            <path fill-rule="evenodd" d="M0 0h1v15h15v1H0V0zm10 3.5a.5.5 0 0 1 .5-.5h4a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-1 0V4.9l-3.613 4.417a.5.5 0 0 1-.74.037L7.06 6.767l-3.656 5.027a.5.5 0 0 1-.808-.588l4-5.5a.5.5 0 0 1 .758-.06l2.609 2.61L13.445 4H10.5a.5.5 0 0 1-.5-.5z"/>
                        </svg>
                    </span>
                    Complexity growth
                </button> -->

                <div style="width: 100%; padding-top: 2px; padding-bottom: 0px;"></div>

               
                <!-- <div class="form-check form-switch small float-right"> 
                    <input type="checkbox" class="form-check-input" id="switchTemporalEdges">
                    <label class="form-check-label d-flex justify-content-between" for="switchTemporalEdges"><small>Temporal edges </small> <span id="badge_add_temporal_edges" data-bs-toggle="tooltip" data-bs-placement="bottom" data-bs-html="true" class="badge rounded-pill text-bg-primary"> ?</span> </label>
                </div>

                <div class="form-check form-switch small float-right"> 
                    <input type="checkbox" class="form-check-input" id="switchHighlightTemporalEdges">
                    <label class="form-check-label d-flex justify-content-between" for="switchHighlightTemporalEdges"><small>Highlight temp </small> <span id="badge_highlight_teporal_edges" data-bs-toggle="tooltip" data-bs-placement="bottom" data-bs-html="true" class="badge rounded-pill text-bg-primary"> ?</span> </label>
                </div> -->

                <div style="width: 100%; padding-top: 6px; padding-bottom: 0px;"></div>

                <li class="list-group-item small d-flex justify-content-between align-items-center disabled" style="max-height: 24px; border: 0px; margin-bottom: 0px; padding-left: 0px;">
                    <small style="font-size: 10px;">Heatmap settings </small>
                    <div class="form-group" style="width: 38%; padding: 0px;">
                        <hr>
                    </div>
                </li>
                
                <div class="form-check form-switch small float-right"> 
                    <input type="checkbox" class="form-check-input" id="switchActivateHeatmap">
                    <label class="form-check-label d-flex justify-content-between" for="switchActivateHeatmap"><small>Normal Heatmap </small> <span id="badge_heat_map_normal" data-bs-toggle="tooltip" data-bs-placement="bottom" data-bs-html="true" class="badge rounded-pill text-bg-primary"> ?</span> </label>
                </div>

                <div class="form-check form-switch small float-right"> 
                    <input type="checkbox" class="form-check-input" id="switchMergeHeatmap">
                    <label class="form-check-label d-flex justify-content-between" for="switchMergeHeatmap"><small>Hybrid Heatmap</small> <span id="badge_heat_map_hybrid" data-bs-toggle="tooltip" data-bs-placement="bottom" data-bs-html="true" class="badge rounded-pill text-bg-primary"> ?</span> </label>
                </div>

                <div id="formSwitchChurnHeatmap" class="form-check form-switch small float-right"> 
                    <input type="checkbox" class="form-check-input" id="switchChurnHeatmap">
                    <label class="form-check-label d-flex justify-content-between" for="switchChurnHeatmap"><small>Churn Heatmap </small> <span id="badge_heat_map_churn" data-bs-toggle="tooltip" data-bs-placement="bottom" data-bs-html="true" class="badge rounded-pill text-bg-primary"> ?</span> </label>
                </div>

                <div id="formSwitchHotspotHeatmap" class="form-check form-switch small float-right"> 
                    <input type="checkbox" class="form-check-input" id="switchHotspotHeatmap">
                    <label class="form-check-label d-flex justify-content-between" for="switchHotspotHeatmap"><small>Hotspot Heatmap </small> <span id="badge_heat_map_hotspot" data-bs-toggle="tooltip" data-bs-placement="bottom" data-bs-html="true" class="badge rounded-pill text-bg-primary"> ?</span> </label>
                </div>

                <div style="width: 100%; padding-top: 6px; padding-bottom: 0px;"></div>

                <label id="inputNodeSearchLabel" for="inputNodeSearch">0 nodes found</label>
                
                <div class="input-group mb-1 input-group-sm">
                    <input id="inputNodeSearch" type="text" class="form-control" placeholder="Search nodes" aria-label="Search" aria-describedby="search-addon">
                    <button class="btn btn-primary " type="button" id="inputNodeSearchCancel">
                        <svg width="16px" height="16px" viewBox="0 0 18 18" class="bi bi-graph-up" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                            <path d="M14 1a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h12zM2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2z"/>
                            <path d="M4.646 4.646a.5.5 0 0 1 .708 0L8 7.293l2.646-2.647a.5.5 0 0 1 .708.708L8.707 8l2.647 2.646a.5.5 0 0 1-.708.708L8 8.707l-2.646 2.647a.5.5 0 0 1-.708-.708L7.293 8 4.646 5.354a.5.5 0 0 1 0-.708z"/>
                        </svg>
                    </button>

                    <div style="width: 100%; padding-top: 8px; padding-bottom: 0px;"></div>
                    <div class="form-check form-switch small float-right" style="width: 100%;"> 
                        <input type="checkbox" class="form-check-input" id="switchAddSemanticSearch">
                        <label class="form-check-label d-flex justify-content-between" for="switchAddSemanticSearch"><small>Add semantics</small> <span id="badge_semantic_search" data-bs-toggle="tooltip" data-bs-placement="bottom" data-bs-html="true" class="badge rounded-pill text-bg-primary"> ?</span> </label>
                    </div>

                </div>
                
                <li class="list-group-item small d-flex justify-content-between align-items-center" style="padding-left: 0px; padding-right: 1px;" >
                    <label style="margin-bottom: 0px; font-size: 10px;"> Hover/select cluster hulls </label> <span id="badge_cluster_hulls" data-bs-toggle="tooltip" data-bs-placement="bottom" data-bs-html="true" class="badge rounded-pill text-bg-primary" customClass="large-tooltip"> ?</span>
                </li>

                <div id="clusterHullMenu">
                <!-- cluster hull selection / injected by javascript -->
                </div>

                </ul>

            </div>

            <!-- Modal -->
            <div class="modal fade" id="overallMetricsModal" tabindex="-1" role="dialog" aria-labelledby="overallMetricsModalLabel" aria-hidden="true">
                <div class="modal-dialog" role="document">
                    <div class="modal-content">

                        <div class="modal-header">
                            <h1 class="modal-title fs-5" id="exampleModalLabel">Overall metrics</h1>
                            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                        </div>

                        <div class="modal-body">
                            <table class="card-table table table-condensed">
                                <thead class="table-borderless">
                                    <tr>
                                        <th scope="col">Metric</th>
                                        <th scope="col">Value</th>
                                    </tr>
                                </thead>
                                <tbody id="tbody-metrics">
                                    <!-- injected by js -->
                                </tbody>
                            </table>
                        </div>

                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                        </div>

                    </div>
                </div>
            </div>
            <!-- end modal -->

            <div class="toast-container position-fixed top-0 start-0 p-3">
            <div id="toastDateRangeUpdated" class="toast align-items-center" role="alert" aria-live="assertive" aria-atomic="true" data-bs-delay="3500">
                <div class="d-flex">
                  <div class="toast-body small">
                    Git date range updated, metrics, visualizations and graph structures may have changed.
                  </div>
                  <button type="button" class="btn-close me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
                </div>
              </div>
            </div>

            <div class="toast-container position-fixed top-0 start-0 p-3">
                <div id="toastDebug" class="toast align-items-center" role="alert" aria-live="assertive" aria-atomic="true" data-bs-delay="2000">
                    <div class="d-flex">
                        <div id="toastDebugMessage" class="toast-body small">
                            text
                        </div>
                        <button type="button" class="btn-close me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
                    </div>
                </div>
            </div>

        </div>

        <script src="vendors/dark-mode-switch/js/dark-mode-switch.min.js"></script>

    </div>

    <script>
        // Some JS code is derived/borrowed or heavily inspired from demos/examples by the following people:
        // Mike Bostock - https://github.com/mbostock, https://bost.ocks.org/mike/
        // Tom Roth - https://bl.ocks.org/puzzler10/4438752bb93f45dc5ad5214efaa12e4a
        // Ma'moun othman/@mamounothman - https://stackoverflow.com/questions/61800343/d3-js-version-5-chart-to-pdf
        // Sam Leach/@SamuelLeach - https://gist.github.com/samuelleach/5497403
        // Pranav C Balan - https://stackoverflow.com/questions/41287778/get-all-possible-object-keys-from-a-list-of-objects-javascript-typescript
        // If I missed someone or gave wrong credit, please contact me and I'll update this.

        const activeNodeLabelColor = hexToRGB("#333333", 0.6)
        const passiveNodeLabelColor = hexToRGB("#333333", 0.2)
        const dmActiveNodeLabelColor = hexToRGB("#DDDDDD", 0.6)
        const dmPassiveNodeLabelColor = hexToRGB("#DDDDDD", 0.2)

        const activeEdgeColor = hexToRGB("#AAAAAA", 1.0);
        const passiveEdgeColor = hexToRGB("#AAAAAA", 0.2);
        const dmActiveEdgeColor = hexToRGB("#888888", 0.8)
        const dmPassiveEdgeColor = hexToRGB("#888888", 0.2)

        const toolTipMetricItemTextColor = hexToRGB("#333333", 0.7);
        const toolTipMetricItemBoxColor = hexToRGB("#333333", 1.0);
        const toolTipMetricItemBoxFillColor = hexToRGB("#f7f7f7", 1.0);

        const activeSelectionColor = '#FF0000'
        const directoryNodeColor = '#3b8cff'
        const fileNodeColor = '#d1e3ff'
        const defaultNodeColor = '#1f77b4'
        const semanticHeaderYellow = '#f5bc42'

        /**
         * * MARK: - Math constants
         */
        const TWO_TIMES_PI = 2 * Math.PI
        const ONE_THIRD_TWO_TIMES_PI = (1.0 / 3.0) * TWO_TIMES_PI

        /**
         * * MARK: - UI workarounds
         */
        // workaround from https://stackoverflow.com/questions/6985507/one-time-page-refresh-after-first-page-load to fix strange safari full screen loading problems
        let userAgent = navigator.userAgent.toLowerCase();
        if (userAgent.includes('safari')) {
            window.onload = function() {
                if (!window.location.hash) {
                    window.location = window.location + '#loaded';
                    window.location.reload();
                }
            }
        }

        // Workaround to prevent buttons that trigger modals to stay focused after dismiss (https://stackoverflow.com/questions/30322918/bootstrap-modal-restores-button-focus-on-close)
        $('body').on('hidden.bs.modal', '.modal', function() {
            $('#buttonShowOverallMetrics').blur();
            $('#buttonShowOverallStatistics').blur();
        });

        // cancel the node search by pressing the escape key
        $(document).keyup(function(e) {
            if (e.key === "Escape") {
                cancelNodeSearch()
            }
        });

        function setDarkMode(mode) {
            if (mode == true) {
                darkMode = true
                currentActiveNodeLabelColor = dmActiveNodeLabelColor
                currentPassiveNodeLabelColor = dmPassiveNodeLabelColor
                currentActiveEdgeColor = dmActiveEdgeColor
                currentPassiveEdgeColor = dmPassiveEdgeColor
                simulationUpdate()
            } else {
                darkMode = false
                currentActiveNodeLabelColor = activeNodeLabelColor
                currentPassiveNodeLabelColor = passiveNodeLabelColor
                currentActiveEdgeColor = activeEdgeColor
                currentPassiveEdgeColor = passiveEdgeColor
                simulationUpdate()
            }
        }

        const tooltipTriggerList = document.querySelectorAll('[data-bs-toggle="tooltip"]')
        const tooltipList = [...tooltipTriggerList].map(tooltipTriggerEl => new bootstrap.Tooltip(tooltipTriggerEl))

        /**
         * * MARK: - Metric info badge tooltip descriptions
         */
        const description_metric_sloc_in_file = '"Source lines of code (SLOC), also known as lines of code (LOC), is a software metric used to measure the size of a computer program by counting the number of lines in the text of the programs source code. SLOC is typically used to predict the amount of effort that will be required to develop a program, as well as to estimate programming productivity or maintainability once the software is produced." (Wikipedia)'
        const description_metric_number_of_methods = 'A metric representing the total number of methods found per file or entity. This is similar to a weighted methods per class (WMC) metric with a uniform complexity/weight of 1.'
        const description_metric_fan_in = '"Fan-in coupling (afferent coupling) the number of entities that depend on a given entity. It estimates in what extent the "external world" depends on the changes in a given entity" (gcc.gnu.org). This metric represents the number of dependencies FROM other files or entities.'
        const description_metric_fan_out = '"Fan-out coupling (efferent coupling) the number of entities the given entity depends upon. It estimates in what extent the given entity depends on the changes in "external world" (gcc.gnu.org). This metric represents the number of dependencies TO other files or entities.'
        const description_metric_louvain_modularity = '"The Louvain method for community detection is a method to extract communities from large networks" (Wikipedia). This metric seperates detected communities by a unique number/ node size.'
        const description_heat_map_normal = '"A heat map (or <strong>heatmap</strong>) is a data visualization technique that shows magnitude of a phenomenon as color in two dimensions" (Wikipedia). The heatmap score is based on a weighted score from the fan-out and SLOC metric. Red color indicates a warning (hotspot), that given metric scores may be to high, while decreasing into blue color.'
        const description_heat_map_hybrid = 'This is a visual (hybrid) <strong>combination</strong> of the normal graph visualization and a heatmap layer behind it'
        const description_unselected_opacity = 'Set the opacity for all unselected nodes after selecting a few with <br><br><strong>shift + s</strong><br><br> and fading all others with <br><br><strong>shift + f</strong>'

        const description_semantic_search = 'Enrich the search results by including semantic keywords (computed by <strong>tf-idf</strong>) which try to describe the content of a node more exactly'
        const description_cluster_hulls = 'Hover over a cluster node color to get a highlighted preview of the concave hull of the appropriate cluster and display basic cluster statistics via tooltip. In addition to that you can also mark/select multiple cluster hulls that will then render permanently.'

        const wide_tooltip_template =
        `
        '<div class="tooltip wide-tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>'
        `

        const description_shortcuts_tooltip =
            `
            <b>shift + s</b> 👉 (de)select hovered nodes
            <br>

            <b>shift + r</b> 👉 resets selected nodes
            <br>
        
            <b>shift + e</b> 👉 selects all nodes linked to selected nodes
            <br>
        
            <b>shift + h</b> 👉 selects all nodes linked to hovered node
            <br>
        
            <b>shift + f</b> 👉 fade unselected nodes</span>
            `
        let description_project_info = ""
        let description_graph_info = ""

        let heatmapMerged = false
        let heatmapActive = false
        let heatmapChurn = false
        let heatmapHotspot = false

        let addTemporalEdges = false

        let selectedNodesMap = {}
        var unselectedNodesOpacity = 0.20
        let fadeUnselectedNodes = false
        let currentActiveNodeLabelColor = activeNodeLabelColor
        let currentPassiveNodeLabelColor = passiveNodeLabelColor

        let currentActiveEdgeColor = activeEdgeColor
        let currentPassiveEdgeColor = passiveEdgeColor

        let dateRangePickerFrom = ""
        let dateRangePickerTo = ""

        let commit_dates = commit_metrics.map(x => x.date);
        let commit_first_date = commit_dates[0]
        let commit_last_date = commit_dates[commit_dates.length - 1]

        let includeGitMetrics = false
        let gitMetricsIndexFrom = 0
        let gitMetricsIndexTo = 0

        dateRangePickerFrom = commit_first_date
        dateRangePickerTo = commit_last_date
        
        const nodeStrokeStyle = "#333333";

        let darkMode = false
        let isSearching = false
        let addSemanticSearch = false
        let searchString = ""

        let searchTerms = []
        let searchResults = 0

        const radius = 7;
        const height = window.innerHeight * 2;
        const graphWidth = window.innerWidth * 2;

        const maxClusterHulls = 20
        let selectedClusterHullIds = []
        let hoveredClusterHullId = undefined

        let nodeLabelsEnabled = false

        let currentTranslation = {
            horizontal: 0,
            vertical: 0,
            lastDirection: ""
        }

        let activeMetrics
        let currentMetricKeys

        let currentGraphType
        let closeNode;

        // daterangepicker for git date range
        function initDateRangeUI() {
            $('input[name="daterange"]').daterangepicker({
                "startDate": commit_first_date,
                "endDate": commit_last_date,
                "minDate": commit_first_date,
                "maxDate": commit_last_date,

                isInvalidDate: function(date) {
                    if ( commit_dates.includes(date.format('DD/MM/YYYY')) ) {
                        return false
                    } else {
                        return true
                    }
                },

                "locale": {
                    "format": "DD/MM/YYYY",
                    "separator": " - ",
                    "applyLabel": "Apply",
                    "cancelLabel": "Cancel",
                    "fromLabel": "From",
                    "toLabel": "To",
                    "customRangeLabel": "Custom",
                    "weekLabel": "W",
                    "daysOfWeek": [
                        "Su",
                        "Mo",
                        "Tu",
                        "We",
                        "Th",
                        "Fr",
                        "Sa"
                    ],
                    "monthNames": [
                        "January",
                        "February",
                        "March",
                        "April",
                        "May",
                        "June",
                        "July",
                        "August",
                        "September",
                        "October",
                        "November",
                        "December"
                    ],
                    "firstDay": 1
                },

                opens: 'left'
            }, function(start, end, label) {
                console.log("A new date selection was made: " + start.format('DD/MM/YYYY') + ' to ' + end.format('DD/MM/YYYY'));
                dateRangePickerFrom = start.format('DD/MM/YYYY')
                dateRangePickerTo = end.format('DD/MM/YYYY')

                // console.log(dateRangePickerFrom)
                // console.log(dateRangePickerTo)
                
                initGitMetricsForDateRange()
                showToastDateRangeUpdate()
            })
        }

        function showToastDateRangeUpdate() {
            const toastLiveExample = document.getElementById('toastDateRangeUpdated')
            const toast = new bootstrap.Toast(toastLiveExample)    
            toast.show()
        }

        function showDebugToast(message) {
            const toastDebug = document.getElementById('toastDebug')
            const toast = new bootstrap.Toast(toastDebug)
            const div = document.querySelector("#toastDebugMessage");
            div.innerHTML = message;
            toast.show()
        }

        function clickDateRangePickerCancel() {
            console.log("reset date range picker")
            initDateRangeUI()
            dateRangePickerFrom = commit_first_date
            dateRangePickerTo = commit_last_date
            initGitMetricsForDateRange()
            showToastDateRangeUpdate()
        }

        function initGitMetricsForDateRange() {
            gitMetricsIndexFrom = commit_dates.indexOf( dateRangePickerFrom );
            gitMetricsIndexTo = commit_dates.lastIndexOf( dateRangePickerTo );
            // console.log("found first index: " + gitMetricsIndexFrom + " for `from` " + dateRangePickerFrom)
            // console.log("found last index: " + gitMetricsIndexTo + " for `to` " + dateRangePickerTo)
            addGitMetricToFileNodes()
        }

        function calculateFileChurnForDateRange() {
            let totalFileChurnDict = {}

            for (let i = gitMetricsIndexFrom; i < gitMetricsIndexTo; i++) {
                let nextChurnDict = commit_metrics[i].churn
                totalFileChurnDict = mergeDicts(totalFileChurnDict, nextChurnDict)
            }

            return totalFileChurnDict
        }

        function calculateWhiteSpaceComplexityForDateRange() {
            let totalWhiteSpaceComplexityDict = {}

            for (let i = gitMetricsIndexFrom; i < gitMetricsIndexTo; i++) {
                let nextWhiteSpaceComplexityDict = commit_metrics[i].ws_complexity
                totalWhiteSpaceComplexityDict = mergeDicts(totalWhiteSpaceComplexityDict, nextWhiteSpaceComplexityDict)
            }

            return totalWhiteSpaceComplexityDict
        }

        function addGitMetricToFileNodes() {
            if (currentGraphType.includes('file_result_dependency_graph')) {
                let fileChurnMap = calculateFileChurnForDateRange()
                let whiteSpaceComplexityMap = calculateWhiteSpaceComplexityForDateRange()

                currentGraph.nodes.forEach(function(node, i) {

                    // housekeeping git code churn
                    delete node['metric_git_code_churn']
                    if (node.hasOwnProperty('metrics')) {
                        delete node.metrics['metric_git_code_churn']
                    }

                    // housekeeping git ws complexity
                    delete node['metric_git_ws_complexity']
                    if (node.hasOwnProperty('metrics')) {
                        delete node.metrics['metric_git_ws_complexity']
                    }

                    if (!node.hasOwnProperty('metrics')) {
                        node.metrics = {}
                    }

                    let nodeFileName = node.id.split("/").pop();

                    // add git code churn
                    if (nodeFileName in fileChurnMap) {
                        node['metric_git_code_churn'] = fileChurnMap[nodeFileName]
                        node.metrics['metric_git_code_churn'] = fileChurnMap[nodeFileName]
                    }

                    // add git whitespace complexity
                    if (nodeFileName in whiteSpaceComplexityMap) {
                        node['metric_git_ws_complexity'] = whiteSpaceComplexityMap[nodeFileName]
                        node.metrics['metric_git_ws_complexity'] = whiteSpaceComplexityMap[nodeFileName]
                    }
                });
            }
        }

        // https://copyprogramming.com/howto/javascript-dictionary-merge-best-methods-to-combine-key-value-pairs?utm_content=cmp-true
        function mergeDicts(dict1, dict2) {
            const result = {};
            for (const key in dict1) {
                if (dict2.hasOwnProperty(key)) {
                    result[key] = dict1[key] + dict2[key];
                } else {
                    result[key] = dict1[key];
                }
            }
            for (const key in dict2) {
                if (!dict1.hasOwnProperty(key)) {
                    result[key] = dict2[key];
                }
            }
            return result;
        }


        function setDirection(direction) {
            currentTranslation.lastDirection = direction
        }

        function toggleNodeLabels() {
            nodeLabelsEnabled = !nodeLabelsEnabled
            simulationUpdate()
        }

        let zoom_handler = d3.zoom()
            .on("zoom", zoomed);

        let graphCanvas = d3.select('#graphDiv').append('canvas')
            .attr('width', graphWidth + 'px')
            .attr('height', height + 'px')
            .attr('id', 'mainCanvas')
            .node();

        let graphData = {}
        let currentGraph = ''

        let clusterMap = {}
        let clusterMetricsMap = {}

        let statistics
        let overall_metric_results

        initAppConfig()
        initHeatmapSwitches()

        initAddTemporalSwitch()

        initSemanticSearchSwitch()
        setInitialDarkMode()
        prepareGraphStructures()
        initAppUI()

        let context = graphCanvas.getContext('2d');

        // nice fix from https://stackoverflow.com/questions/8696631/canvas-drawings-like-lines-are-blurry to remove blurry drawing
        graphCanvas.style.height = (height / 2) + "px";
        graphCanvas.style.width = (graphWidth / 2) + "px";
        graphCanvas.getContext('2d').scale(2, 2);

        let div = d3.select("body").append("div")
            .attr("class", "tooltip")
            .style("opacity", 0);

        let currentChargeForce = -500
        let currentLinkDistance = 20
        let simulation

        let transform = d3.zoomIdentity;

        // heatmap
        var heat = simpleheat('mainCanvas');

        // bring back d3 schemeCategory20 to live
        const schemeCategory20 = "1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5"

        function d3ColorExport(specifier) {
            let n = specifier.length / 6 | 0,
                colors = new Array(n),
                i = 0;
            while (i < n) colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
            return colors;
        }

        // important to define the domain for the ordinal scale
        const color = d3.scaleOrdinal(d3ColorExport(schemeCategory20))
            .domain([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19])

        /**
         * * MARK: - Connectivity checks 
         */
        let linkedByIndex = {};

        function isConnected(a, b) {
            return isConnectedAsTarget(a, b) || isConnectedAsSource(a, b) || a.id === b.id;
        }

        function isConnectedAsSource(a, b) {
            return linkedByIndex[`${a.id},${b.id}`];
        }

        function isConnectedAsTarget(a, b) {
            return linkedByIndex[`${b.id},${a.id}`];
        }

        function edgeBetweenSearchTerms(sourceNode, targetNode) {
            let found = false
            searchTerms.forEach(element => {
                if ( (sourceNode.id.toLowerCase().includes(element)) && (targetNode.id.toLowerCase().includes(element)) ) {
                    found = true
                }
            });
            return found
        }

        function searchTermsIncludedInNodeTags(sourceNode, targetNode) {
            let found = false
            searchTerms.forEach(element => {
                if ((stringIncludedInNodeTags(element, sourceNode) && stringIncludedInNodeTags(element, targetNode))) {
                    found = true
                }
            });
            return found
        }

        /**
         * * MARK: - Drawing on canvas
         */
         function drawEdges(context) {
            currentGraph.links.forEach(function(d) {

                context.beginPath();
                context.moveTo(d.source.x, d.source.y);
                context.lineTo(d.target.x, d.target.y);

                if (closeNode == null) { // not hovering over any node
                    if (isSearching == false) { // not searching                     
                        context.fillStyle = context.strokeStyle = nodeSourceColor = nodeColorByModularity(d.source, 0.7)

                    } else { // node search is active

                        if (addSemanticSearch == true) {

                            // the edge is between two nodes that are included in the search OR the edge is between two nodes that includes the search in one of their semantic keywords
                            if ( edgeBetweenSearchTerms(d.source, d.target) || searchTermsIncludedInNodeTags(d.source, d.target) )
                            { 
                                context.strokeStyle = currentActiveEdgeColor
                                context.fillStyle = currentActiveEdgeColor
                            } else { // the edge is not connected to a node which is included in the search
                                context.fillStyle = context.strokeStyle = currentPassiveEdgeColor
                            }

                        // normal search without semantic
                        } else {
                            // the edge is between two nodes that are included in the search
                            if (edgeBetweenSearchTerms(d.source, d.target))                            
                            { 
                                context.strokeStyle = currentActiveEdgeColor
                                context.fillStyle = currentActiveEdgeColor
                            } else { // the edge is not connected to a node which is included in the search
                                context.fillStyle = context.strokeStyle = currentPassiveEdgeColor
                            }
                        }
                    }

                } else {
                    if ((d.target.id == closeNode.id) || (d.source.id == closeNode.id)) { // there is an edge that contains our hovered node
                        context.strokeStyle = currentActiveEdgeColor
                        context.fillStyle = currentActiveEdgeColor

                    } else { // node is not included in the edge
                        context.fillStyle = context.strokeStyle = nodeColorByModularity(d.source, 0.2)
                    }   
                }

                // highlight edge if the corresponding nodes are selected
                if (d.source.id.toLowerCase() in selectedNodesMap && d.target.id.toLowerCase() in selectedNodesMap) {
                    context.strokeStyle = activeSelectionColor
                    context.fillStyle = currentActiveEdgeColor
                    context.lineWidth = 2.0;
                } else {
                    if (fadeUnselectedNodes == true || normalHeatmapIsActive() || churnHeatmapIsActive() || hotspotHeatmapIsActive()) { // also fade away non-relevant egdes
                        context.fillStyle = context.strokeStyle = nodeColorByModularity(d.source, unselectedNodesOpacity)
                    } 
                    context.lineWidth = 1.0;
                }

                context.stroke();

                if (closeNode != null && ((d.target.id == closeNode.id) || (d.source.id == closeNode.id))) { // draw an arrow if there is an edge that contains our hovered node
                    drawArrowhead(context, d.source, d.target, 5)

                } else if (isSearching && ( (searchTermIncludedInNode(d.target) ) && ( searchTermIncludedInNode(d.source)) )) { // draw an arrow if searching is enabled and there's an egde between searched nodes
                    drawArrowhead(context, d.source, d.target, 5)
                }
                
                else if (d.source.id.toLowerCase() in selectedNodesMap && d.target.id.toLowerCase() in selectedNodesMap) {
                    drawArrowhead(context, d.source, d.target, 5)
                }                    
                
            });
        }

        function normalSearch(node) {
            let found = false
            searchTerms.forEach(element => {
                if (node.id.toLowerCase().includes(element)) {
                    found = true
                }
            });
            return found
        }

        // the node is included in the current search OR if the search in included in one of the node's semantic tags 
        function searchTermIncludedInNode(node) {
            let found = false
                searchTerms.forEach(element => {
                    if (node.id.toLowerCase().includes(element)) {
                        found = true
                    }
                });
            return found
        } 
        
        function searchTermIncludedInNodeTags(node) {
            let found = false
            searchTerms.forEach(element => {
                if ( stringIncludedInNodeTags(element, node) ) {
                    found = true
                }
            });
            return found
        }

        function drawNodes(context) {
            currentGraph.nodes.forEach(function(d, i) {

                context.beginPath();

                //render outer circle if node was selected
                if (d.id.toLowerCase() in selectedNodesMap) {

                    context.arc(d.x, d.y, d.radius + 2.0, 0, TWO_TIMES_PI);
                    context.fillStyle = '#FF0000' //activeSelectionColor
                    drawNodeLabel(d.id, d.x + 14, d.y - 7)
                    context.fill();
                }

                context.arc(d.x, d.y, d.radius, 0, TWO_TIMES_PI, true);

                if (fadeUnselectedNodes == true || normalHeatmapIsActive() || churnHeatmapIsActive() || hotspotHeatmapIsActive()) {
                    context.strokeStyle = nodeStrokeStyle
                    context.fillStyle = hexToRGB(nodeStrokeStyle, unselectedNodesOpacity)
                    context.stroke();

                    if (nodeLabelsEnabled) {
                        context.fillStyle = currentPassiveNodeLabelColor;
                        drawNodeLabel(d.id, d.x + 14, d.y - 7)
                        context.fillStyle = nodeColorByModularity(d, unselectedNodesOpacity)
                    }

                } else {

                    if (closeNode == null) { // not hovering over any node
                        if (isSearching == false) {

                            context.fillStyle = nodeColorByModularity(d)
                            context.strokeStyle = nodeStrokeStyle;
                            context.stroke();

                            if (nodeLabelsEnabled) {
                                context.fillStyle = currentActiveNodeLabelColor;
                                drawNodeLabel(d.id, d.x + 14, d.y - 7)
                                context.fillStyle = nodeColorByModularity(d)
                            }

                        } else { // searching for nodes

                            // normal (non-semantic) search
                            if ( addSemanticSearch == false &&  normalSearch(d)) {

                                context.fillStyle = nodeColorByModularity(d)
                                context.strokeStyle = nodeStrokeStyle;
                                context.stroke();

                                context.fillStyle = currentActiveNodeLabelColor;
                                drawNodeLabel(d.id, d.x + 14, d.y - 7)
                                context.fillStyle = nodeColorByModularity(d)

                                searchResults += 1

                            } else if ( addSemanticSearch == true && (searchTermIncludedInNode(d) || searchTermIncludedInNodeTags(d)) )
                                // add semantic search
                                // the node is included in the current search OR if the search in included in one of the node's semantic tags 
                                // draw a highlight circle behind the found node due to semantic search
                                {
                                if ( searchTermIncludedInNodeTags(d) )
                                {
                                    context.fillStyle = currentActiveNodeLabelColor;
                                    drawNodeLabel(d.id, d.x + 14, d.y - 7)
                                    
                                    drawNodeHighlight(d, nodeColorByModularity(d, 1.0))
                                    context.strokeStyle = nodeStrokeStyle;
                                    context.stroke();

                                    drawNodeHighlight(d, semanticHeaderYellow, 2)
                                    context.strokeStyle = nodeStrokeStyle;
                                    context.stroke();

                                    searchResults += 1
                                    
                                } else {

                                    context.fillStyle = nodeColorByModularity(d)
                                    context.strokeStyle = nodeStrokeStyle;
                                    context.stroke();

                                    context.fillStyle = currentActiveNodeLabelColor;
                                    drawNodeLabel(d.id, d.x + 14, d.y - 7)
                                    context.fillStyle = nodeColorByModularity(d)

                                    searchResults += 1
                                }

                            } else {
                                context.fillStyle = nodeColorByModularity(d, 0.2)
                                context.strokeStyle = hexToRGB(nodeStrokeStyle, 0.2)
                                context.stroke();

                                if (nodeLabelsEnabled) {
                                    context.fillStyle = currentPassiveNodeLabelColor;
                                    drawNodeLabel(d.id, d.x + 14, d.y - 7)
                                    context.fillStyle = nodeColorByModularity(d, 0.2)
                                }
                            }
                        }

                    } else { // hovering over a node
                        if (isConnected(d, closeNode)) { // node is connected to hovered node
                            context.fillStyle = nodeColorByModularity(d)
                            context.strokeStyle = nodeStrokeStyle;
                            context.stroke();

                            // show/highlight node label of every connected node from the hovered node
                            context.fillStyle = currentActiveNodeLabelColor;
                            drawNodeLabel(d.id, d.x + 14, d.y - 7)
                            context.fillStyle = nodeColorByModularity(d)

                        } else { // node is not connected

                            if (d.id.toLowerCase() in selectedNodesMap) {
                                context.strokeStyle = nodeStrokeStyle
                                context.fillStyle = nodeColorByModularity(d)
                                context.stroke();
                            } else { 
                                context.strokeStyle = hexToRGB(nodeStrokeStyle, 0.2)
                                context.fillStyle = nodeColorByModularity(d, 0.2)
                                context.stroke();
                            }

                            if (nodeLabelsEnabled) {
                                context.fillStyle = currentPassiveNodeLabelColor;
                                drawNodeLabel(d.id, d.x + 14, d.y - 7)
                                context.fillStyle = nodeColorByModularity(d, 0.2)
                            }
                        }
                    }

                } // else not fade away unselected nodes

                context.fill();

                if (i == currentGraph.nodes.length - 1) { // dont call this to often due to performance

                    if (closeNode) {
                        context.beginPath();
                        drawNode(closeNode)

                        if (closeNode.id.toLowerCase() in selectedNodesMap) {
                            context.fillStyle = activeSelectionColor
                        } else {
                            context.fillStyle = nodeColorByModularity(closeNode)
                        }
                        
                        context.fill();
                        context.strokeStyle = "#000000";
                        context.lineWidth = 1.0;
                        context.stroke();

                        drawNodeToolTip(closeNode.id, closeNode.x + 14, closeNode.y - 7, closeNode.metrics)
                    }
                }
            });
        }

        /**
         * * MARK: - Drawing a heatmap for normal / hybrid (merged) mode
         */

         function calculateHeatmapScore(node) {

            let totalScore = 0

            if (normalHeatmapIsActive() || mergedHeatmapIsActive() ) {

                let score = analysis_config['heatmap']['score']['base']
                let slocScore = 0
                let fanoutScore = 0

                if (analysis_config['heatmap']['metrics']['active']['sloc'] == true) {
                    // add weighted sloc metric if present
                    if ('metric_sloc_in_entity' in node) {
                        slocScore = node.metric_sloc_in_entity * analysis_config['heatmap']['metrics']['weights']['sloc']
                    }
                    if ('metric_sloc_in_file' in node) {
                        slocScore = node.metric_sloc_in_file * analysis_config['heatmap']['metrics']['weights']['sloc']
                    }
                }

                if (analysis_config['heatmap']['metrics']['active']['fan_out'] == true) {
                    // add weighted fan-out metric is present
                    if ('metric_fan_out_dependency_graph' in node) {
                        fanoutScore = node.metric_fan_out_dependency_graph * analysis_config['heatmap']['metrics']['weights']['fan_out']
                    }
                    if ('metric_fan_out_inheritance_graph' in node) {
                        fanoutScore = node.metric_fan_out_inheritance_graph * analysis_config['heatmap']['metrics']['weights']['fan_out']
                    }
                    if ('metric_fan_out_complete_graph' in node) {
                        fanoutScore = node.metric_fan_out_complete_graph * analysis_config['heatmap']['metrics']['weights']['fan_out']
                    }
                }

                // limit the total score to the heatmap limit parameter, since the rendering seems to be buggy if this is exceeded
                totalScore = score + slocScore + fanoutScore
                if (totalScore > analysis_config['heatmap']['score']['limit']) {
                    totalScore = analysis_config['heatmap']['score']['limit']
                }

            } else if (churnHeatmapIsActive()) {
                let score = analysis_config['churn_heatmap']['score']['base']
                let churnScore = 0
                
                if (node.hasOwnProperty('metric_git_code_churn')) {
                    if (analysis_config['churn_heatmap']['metrics']['active']['churn'] == true) {
                        churnScore = node.metric_git_code_churn * analysis_config['churn_heatmap']['metrics']['weights']['churn']
                    }
                    
                    totalScore = score + churnScore
                    if (totalScore > analysis_config['churn_heatmap']['score']['limit']) {
                        totalScore = analysis_config['churn_heatmap']['score']['limit']
                    }
                    
                }

            } else if (hotspotHeatmapIsActive()) {
                let score = analysis_config['hotspot_heatmap']['score']['base']
                let churnScore = 0

                if (node.hasOwnProperty('metric_git_code_churn') && node.hasOwnProperty('metric_git_ws_complexity') ) {
                    // TODO
                }


            }

            return totalScore
        }

        function drawHeatMap(context) {

            if (normalHeatmapIsActive() || mergedHeatmapIsActive()) {
                heat.max(analysis_config['heatmap']['score']['limit']);
            }

            if (churnHeatmapIsActive()) {
                heat.max(analysis_config['churn_heatmap']['score']['limit']);
            }

            if (hotspotHeatmapIsActive()) {
                heat.max(analysis_config['hotspot_heatmap']['score']['limit']);
            }

            heat.clear();
            currentGraph.nodes.forEach(function(node, i) {
                heat.add([node.x, node.y, calculateHeatmapScore(node)])
            })

            heat.draw()
            
            // reset alpha from heatmap rendering
            context.globalAlpha = 1;  
        }


        function drawLink(d) {
            context.moveTo(d.source.x, d.source.y);
            context.lineTo(d.target.x, d.target.y);
        }

        function drawNode(d) {
            context.arc(d.x, d.y, d.radius, 0, TWO_TIMES_PI);
        }

        function drawNodeHighlight(node, color, radiusOffset) {
            context.arc(node.x, node.y, node.radius + radiusOffset, 0, TWO_TIMES_PI);
            context.fillStyle = color
            context.strokeStyle = color;
            context.stroke();
            context.fill();
        }

        function drawNodeLabel(text, xPos, yPos) {
            const fontSize = 8
            context.font = fontSize + 'px Helvetica';
            context.fillText(text, xPos, yPos);
        }

        function stringIncludedInNodeTags(string, node) {
            let propertyNames = Object.getOwnPropertyNames(node.metrics)
            let searchedTag = 'metric_tag_' + string
            let found = false

            let tagProperties = propertyNames.filter(function(property) {
                return property.startsWith('metric_tag_')
            })

            tagProperties.forEach(function(propertyName) {
                if (propertyName.toLowerCase().includes(string.toLowerCase())) {
                    found = true
                }
            })
       
            return found
        }

        function drawNodeToolTip(text, xPos, yPos, nodeMetrics) {

            // $('#overallStatisticsModal').modal('show');

            const fontSize = 14
            context.font = fontSize + 'px Helvetica';

            // determine the maximum label width
            let maxLineWidth = 0
            for (metricKey in nodeMetrics) {
                const val = nodeMetrics[metricKey]
                let human_readable_metric_name = metricKey.replace('metric_', '').replace(/_/gi, " ")
                const w = context.measureText(human_readable_metric_name + ": " + val).width;
                if (maxLineWidth < w) {
                    maxLineWidth = w
                }
            }

            // check if actually the title line width if bigger than any metric label line width?
            const nodeTitleLineWidth = context.measureText(text).width
            if (nodeTitleLineWidth > maxLineWidth)
                maxLineWidth = nodeTitleLineWidth

            // draw the header/title of the toolip    
            let lineHeight = fontSize * 1.286;
            context.fillStyle = hexToRGB("#0069d9", 1.0);
            context.fillRect(xPos - 6, (yPos - lineHeight) + 2, maxLineWidth + 10, lineHeight + 4);
            context.strokeStyle = hexToRGB("#333333", 1.0);
            context.strokeRect(xPos - 6, (yPos - lineHeight) + 2, maxLineWidth + 10, lineHeight + 4)

            context.fillStyle = hexToRGB("#FFFFFF", 0.8);
            context.fillText(text, xPos, yPos);

            // now draw the second tooltip box with all metric labels
            let metricItem = 1
            const metricFontSize = 14
            const metricLineHeight = (metricFontSize * 1.286);
            let yPosOffset = yPos + 10
            let newYPos = 0
            let renderWithTags = false

            context.font = metricFontSize + 'px Helvetica';

            for (metricKey in nodeMetrics) {
                
                // do not include any tag/tfidf metric in the primary metric section
                if (metricKey.includes('metric_tag')) {
                    renderWithTags = true
                    continue
                }

                let val = nodeMetrics[metricKey]
                let human_readable_metric_name = metricKey.replace('metric_', '').replace(/_/gi, " ")
                let metricItemText = human_readable_metric_name + ": " + val

                newYPos = yPosOffset + (metricLineHeight * metricItem)

                // Interesting bug: on Safari it seems to cause random lags if you do fillStyle/fillRect BEFORE strokeStyle/strokeRect
                context.strokeStyle = toolTipMetricItemBoxColor
                context.strokeRect(xPos - 6, (newYPos - metricLineHeight), maxLineWidth + 10, metricLineHeight)

                context.fillStyle = toolTipMetricItemBoxFillColor
                context.fillRect(xPos - 6, (newYPos - metricLineHeight), maxLineWidth + 10, metricLineHeight);

                context.fillStyle = toolTipMetricItemTextColor;
                context.fillText(metricItemText, xPos, newYPos - 4);

                metricItem = metricItem + 1
            }

            // render tag/tfidf metric section
            if (renderWithTags) {
                let metricItem = 1
                newYPos += 20
                
                // draw the header/title of the toolip    
                context.fillStyle = hexToRGB("#f5bc42", 1.0);
                context.fillRect(xPos - 6, (newYPos - lineHeight) + 2, maxLineWidth + 10, lineHeight + 4);
                context.strokeStyle = hexToRGB("#333333", 1.0);
                context.strokeRect(xPos - 6, (newYPos - lineHeight) + 2, maxLineWidth + 10, lineHeight + 4)
                context.fillStyle = hexToRGB("#333333", 0.8);
                context.fillText('Semantic keywords', xPos, newYPos);

                let yTagPosOffset = newYPos + 10

                // render tag/tfidf metrics
                for (metricKey in nodeMetrics) {
                    
                    // do not include any tag/tfidf metric in the primary metric section
                    if (!metricKey.includes('metric_tag')) {
                        continue
                    }

                    let val = nodeMetrics[metricKey]
                    let human_readable_metric_name = metricKey.replace('metric_tag', '').replace(/_/gi, "")
                    let metricItemText = human_readable_metric_name // + ": " + val

                    newYPos = yTagPosOffset + (metricLineHeight * metricItem)

                    // Interesting bug: on Safari it seems to cause random lags if you do fillStyle/fillRect BEFORE strokeStyle/strokeRect
                    context.strokeStyle = toolTipMetricItemBoxColor
                    context.strokeRect(xPos - 6, (newYPos - metricLineHeight), maxLineWidth + 10, metricLineHeight)

                    context.fillStyle = toolTipMetricItemBoxFillColor
                    context.fillRect(xPos - 6, (newYPos - metricLineHeight), maxLineWidth + 10, metricLineHeight);

                    context.fillStyle = toolTipMetricItemTextColor;
                    context.fillText(metricItemText, xPos, newYPos - 4);

                    metricItem = metricItem + 1
                }
            }
        }

        // borrowed from Scott Johnson / https://gist.github.com/jwir3/d797037d2e1bf78a9b04838d73436197 with minor adjustments
        function drawArrowhead(context, from, to, radius) {
            const x_center = 0.5 * (from.x + to.x)
            const y_center = 0.5 * (from.y + to.y)

            let angle;
            let x;
            let y;

            context.beginPath();

            angle = Math.atan2(to.y - from.y, to.x - from.x)
            x = radius * Math.cos(angle) + x_center;
            y = radius * Math.sin(angle) + y_center;

            context.moveTo(x, y);

            angle += ONE_THIRD_TWO_TIMES_PI
            x = radius * Math.cos(angle) + x_center;
            y = radius * Math.sin(angle) + y_center;

            context.lineTo(x, y);

            angle += ONE_THIRD_TWO_TIMES_PI
            x = radius * Math.cos(angle) + x_center;
            y = radius * Math.sin(angle) + y_center;

            context.lineTo(x, y);
            context.closePath();
            context.fill();
        }

        function nodeColorByModularity(node, alpha = 1.0) {
            if (currentGraphType.includes('file_result') || currentGraphType.includes('filesystem')) {
                if ('metric_file_result_dependency_graph_louvain_modularity_in_file' in node) {
                    return hexToRGB(color(node.metric_file_result_dependency_graph_louvain_modularity_in_file), alpha)
                } else if ('directory' in node) {
                    if (node.directory == true) {
                        return hexToRGB(directoryNodeColor)
                    }
                }
            } else {
                if (currentGraphType.includes('entity_result_dependency_graph')) {
                    if ('metric_entity_result_dependency_graph_louvain_modularity_in_entity' in node) {
                        return hexToRGB(color(node.metric_entity_result_dependency_graph_louvain_modularity_in_entity), alpha)
                    }
                }
                if (currentGraphType.includes('entity_result_inheritance_graph')) {
                    if ('metric_entity_result_inheritance_graph_louvain_modularity_in_entity' in node) {
                        return hexToRGB(color(node.metric_entity_result_inheritance_graph_louvain_modularity_in_entity), alpha)
                    }
                }
                
                if (currentGraphType.includes('entity_result_complete_graph')) {
                    if ('metric_entity_result_complete_graph_louvain_modularity_in_entity' in node) {
                        return hexToRGB(color(node.metric_entity_result_complete_graph_louvain_modularity_in_entity), alpha)
                    }
                }
            }

            return hexToRGB(defaultNodeColor) 
        }

        function setInitialDarkMode() {
            if (document.body.getAttribute("data-theme") == "dark") {
                currentActiveNodeLabelColor = dmActiveNodeLabelColor
                currentPassiveNodeLabelColor = dmPassiveNodeLabelColor
                currentActiveEdgeColor = dmActiveEdgeColor
                currentPassiveEdgeColor = dmPassiveEdgeColor
                darkMode = true
            } else {
                currentActiveNodeLabelColor = activeNodeLabelColor
                currentPassiveNodeLabelColor = passiveNodeLabelColor
                currentActiveEdgeColor = activeEdgeColor
                currentPassiveEdgeColor = passiveEdgeColor
                darkMode = false
            }
        }

        /**
         * * MARK: - Rendering concave hulls of clusters.
         */
        function setupGraphClustersById() {
            clusterMap = {}
            currentGraph.nodes.forEach(function(node, i) {
                let nodeClusterId = 0

                if (node.hasOwnProperty('metric_file_result_dependency_graph_louvain_modularity_in_file')) {
                    nodeClusterId = node.metric_file_result_dependency_graph_louvain_modularity_in_file
                } else if (node.hasOwnProperty('metric_entity_result_dependency_graph_louvain_modularity_in_entity')) {
                    nodeClusterId = node.metric_entity_result_dependency_graph_louvain_modularity_in_entity
                } else if (node.hasOwnProperty('metric_entity_result_inheritance_graph_louvain_modularity_in_entity')) {
                    nodeClusterId = node.metric_entity_result_inheritance_graph_louvain_modularity_in_entity
                } else if (node.hasOwnProperty('metric_entity_result_complete_graph_louvain_modularity_in_entity')) {
                    nodeClusterId = node.metric_entity_result_complete_graph_louvain_modularity_in_entity
                }

                nodeClusterId = nodeClusterId.toString()

                if (nodeClusterId in clusterMap) {
                    clusterMap[nodeClusterId].push(node)
                } else {
                    clusterMap[nodeClusterId] = []
                    clusterMap[nodeClusterId].push(node)
                }
            })

            // console.log(clusterMap)
        }

        function onMouseOverHullMenuNode(clusterId) {
            if (!selectedClusterHullIds.includes(clusterId)) {
                addHighlightToSVGCircle(clusterId)
            }
            hoveredClusterHullId = clusterId
            simulationUpdate()
        }

        function onMouseOutHullMenuNode(clusterId) {
            if (!selectedClusterHullIds.includes(clusterId)) {
                removeHighlightFromSVGCircle(clusterId)
            }
            hoveredClusterHullId = undefined
            simulationUpdate()
        }

        function addHighlightToSVGCircle(clusterId) {
            let hullNodeSVG = $("#clusterHullNodeSVGCircle-" + clusterId)
            hullNodeSVG.attr('stroke', 'yellow')
            hullNodeSVG.attr('stroke-width', '2')
        }

        function removeHighlightFromSVGCircle(clusterId) {
            let hullNodeSVG = $("#clusterHullNodeSVGCircle-" + clusterId)
            hullNodeSVG.attr('stroke', 'black')
            hullNodeSVG.attr('stroke-width', '1')
        }

        function onClickHullMenuNode(clusterId) {
            if (selectedClusterHullIds.includes(clusterId)) {
                removeItemAll(selectedClusterHullIds, clusterId)
                removeHighlightFromSVGCircle(clusterId)
            } else {
                selectedClusterHullIds.push(clusterId)
                addHighlightToSVGCircle(clusterId)
            }
            simulationUpdate()
        }

        function createClusterHullMenu() {
            // check if there is at least one cluster
            if ("0" in clusterMap) {
                // build menu
                let clusterMenuHtml = "<div id=\"clusterHullContainer\"> \
                                        <div class=\"row\">"

                clusterMenuHtml += "<div class=\"svg-column\">"

                // insert SVG circles
                let iteration = 0
                Object.keys(clusterMap).forEach(function(key) {

                    if (iteration < maxClusterHulls) {
                        let firstNode = clusterMap[key][0]
                        let color = nodeColorByModularity(firstNode)

                        let svgElement = "<svg onmouseover=\"onMouseOverHullMenuNode(" + key + ")\" onmouseout=\"onMouseOutHullMenuNode(" + key + ")\" onclick=\"onClickHullMenuNode(" + key + ")\" height=\"16px\" width=\"16px\" viewBox=\"0 0 18 18\"><circle id=\"clusterHullNodeSVGCircle-" + key + "\" cx=\"5\" cy=\"10\" r=\"4\" \
                                stroke=\"black\" stroke-width=\"1\" fill=\""
                        svgElement += color
                        svgElement += "\" /></svg>"
                        clusterMenuHtml += svgElement
                    }
                    iteration += 1
                });

                // finish menu and append to div
                clusterMenuHtml += "</div></div></div>"
                d3.select("#clusterHullMenu").html(clusterMenuHtml)

                // add tooltips to cluster hull nodes
                iteration = 0
                Object.keys(clusterMap).forEach(function(clusterId) {
                    if (iteration < maxClusterHulls) {
                        let clusterToolTipDescription = "<u>Cluster metrics</u><br>"
                        let clusterMetrics = clusterMetricsMap[clusterId]

                        // TODO: check why clusterMetrics can be undefined
                        if (clusterMetrics !== undefined) {
                            // add all cluster metrics that we can find
                            Object.keys(clusterMetrics).forEach(function(clusterMetric) {
                                let metricPrettyName = clusterMetric.replace(/_/gi, " ").replace(/metric/gi, "")
                                clusterToolTipDescription += metricPrettyName + ": " + "<b>" + clusterMetrics[clusterMetric] + "</b>" + "<br>"
                            })

                            $('#' + 'clusterHullNodeSVGCircle-' + clusterId).attr('data-bs-toggle', 'tooltip')
                            $('#' + 'clusterHullNodeSVGCircle-' + clusterId).attr('data-bs-title', clusterToolTipDescription)
                            $('#' + 'clusterHullNodeSVGCircle-' + clusterId).attr('data-bs-html', 'true')
                            $('#' + 'clusterHullNodeSVGCircle-' + clusterId).attr('data-bs-placement', 'bottom')

                        }
                    }
                })
            }

            const tooltipTriggerList = document.querySelectorAll('[data-bs-toggle="tooltip"]')
            const tooltipList = [...tooltipTriggerList].map(tooltipTriggerEl => new bootstrap.Tooltip(tooltipTriggerEl))
        }

        function getPointArrayForClusterId(id) {
            let pointArray = []
            let clusterId = id.toString()

            if (clusterId in clusterMap) {
                clusterMap[clusterId].forEach(function(node, i) {
                    pointArray.push([node.x, node.y])
                })
            }
            return pointArray
        }

        // calculate hull
        function getHullFromPointArray(pointArray) {
            let hullArray = hull(pointArray, 60)
            return hullArray
        }

        /**
         * * MARK: - Translations on canvas
         */
        function translateCanvas(direction) {
            switch (direction) {
                case 'left':
                    transform.x += 100
                    simulationUpdate()
                    break;

                case 'down':
                    transform.y -= 100
                    simulationUpdate()
                    break;

                case 'right':
                    transform.x -= 100
                    simulationUpdate()
                    break;

                case 'up':
                    transform.y += 100
                    simulationUpdate()
                    break;
            }
        }

        /**
         * * MARK: - Adjusting style 
         */

        function unselectedOpacityChange(val) {
            unselectedNodesOpacity = val / 100.0
            simulationUpdate()
        }

        /**
         * * MARK: - Zooming and scaling on canvas
         */
        function zoomed(event) {
            transform = event.transform;
            simulationUpdate();
        }

        function zoomIn() {
            d3.select(graphCanvas)
                .call(zoom_handler.scaleBy, 2)
                .call(d3.zoom().scaleExtent([1 / 10, 8]).on("zoom", zoomed))
            simulationUpdate()
        }

        function zoomOut() {
            d3.select(graphCanvas)
                .call(zoom_handler.scaleBy, 0.5)
                .call(d3.zoom().scaleExtent([1 / 10, 8]).on("zoom", zoomed))
            simulationUpdate()
        }

        startWithGraph(currentGraphType)
        zoomOut() // initialliy zoom out a bit

        /**
         * * MARK: - Called on startup an d every time you change a graph
         */
        function startWithGraph(graphType, chargeForce = currentChargeForce, linkDistance = currentLinkDistance) {

            activeMetrics = []
            currentMetricKeys = []

            currentGraphType = graphType

            currentLinkDistance = linkDistance
            currentChargeForce = chargeForce
            currentLinkDistance = linkDistance

            resetSimulationData()

            currentGraph = JSON.parse(JSON.stringify(graphData[graphType]['graph']))
            statistics = graphData[graphType]['statistics']
            overall_metric_results = graphData[graphType]['overall_metric_results']
            clusterMetricsMap = graphData[graphType]['cluster_metrics_map']

            addGitMetricToFileNodes()

            createStatistics();
            createOverallMetricResults();

            currentGraph.nodes.forEach(function(d, i) {
                d.radius = radius

                if (!d.hasOwnProperty('metrics')) {
                    d.metrics = {}
                }

                for (let key in d) {

                    if (key.includes('metric_')) {
                        d.metrics[key] = d[key]
                        if (!currentMetricKeys.includes(key)) {
                            // do not include tag/tfidf metrics in the 'apply metrics' dropDown menu
                            if (!key.includes('metric_tag')) {
                                currentMetricKeys.push(key)
                            }                            
                        }
                    }
                }
            });

            setupGraphClustersById();
            
            createClusterHullMenu();
            createMetricsMenuEntries();

            updateAppUI()
            
            enableSearchInput();
            enableNodeSelection();

            addToolTipsToMetricEntries();
            addToolTipsToHeatMap();
            addToolTipToShortcuts();
            addTooltipUnselectedOpacity();
            addTooltipSemanticSearch();
            addTooltipClusterHulls();

            currentGraph.links.forEach((d) => {
                linkedByIndex[`${d.source},${d.target}`] = true;
            });

            simulation = d3.forceSimulation()
                .force("center", d3.forceCenter(graphWidth / 4, height / 4))
                .force("x", d3.forceX(graphWidth / 2).strength(0.1))
                .force("y", d3.forceY(height / 2).strength(0.1))
                .force("charge", d3.forceManyBody().strength(currentChargeForce))
                .force("link", d3.forceLink()
                    .strength(1)
                    .distance(currentLinkDistance)
                    .id(function(d) {
                        return d.id;
                    }))
                .alphaTarget(0)
                .alphaDecay(0.05)

            addGraphTypeSelectionToMenu()

            addTooltipProjectInfo();
            addTooltipGraphInfo();
            
            d3.select(graphCanvas)
                .call(d3.drag().subject(dragsubject).on("start", dragstarted).on("drag", dragged).on("end", dragended))
                .call(d3.zoom().scaleExtent([1 / 10, 8]).on("zoom", zoomed))

            function dragsubject(event) {

                let i,
                    x = transform.invertX(event.x),
                    y = transform.invertY(event.y),
                    dx,
                    dy;

                for (i = currentGraph.nodes.length - 1; i >= 0; --i) {
                    node = currentGraph.nodes[i];
                    dx = x - node.x;
                    dy = y - node.y;

                    if (dx * dx + dy * dy < radius * radius) {

                        node.x = transform.applyX(node.x);
                        node.y = transform.applyY(node.y);

                        return node;
                    }
                }
            }

            function dragstarted(event) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                event.subject.fx = transform.invertX(event.x);
                event.subject.fy = transform.invertY(event.y);
            }

            function dragged(event) {
                event.subject.fx = transform.invertX(event.x);
                event.subject.fy = transform.invertY(event.y);
            }

            function dragended(event) {
                if (!event.active) simulation.alphaTarget(0);
                event.subject.fx = null;
                event.subject.fy = null;
            }
            
            d3.select("canvas").on("mousemove", (event) => {
                let p = d3.pointer(event);
                let invX = transform.invertX(p[0])
                let invY = transform.invertY(p[1])

                let foundNode = simulation.find(transform.invertX(p[0]), transform.invertY(p[1]));

                // check within a close area if hovered point is nearby of foundNode
                if ((Math.abs(foundNode.x - invX) < radius) && (Math.abs(foundNode.y - invY) < radius)) {
                    closeNode = simulation.find(transform.invertX(p[0]), transform.invertY(p[1]));
                } else {
                    closeNode = null
                }

                simulationUpdate();
            })

            simulation.nodes(currentGraph.nodes)
                .on("tick", simulationUpdate);

            simulation.force("link")
                .links(currentGraph.links);
        }

        // Based on https://bl.ocks.org/jodyphelan/5dc989637045a0f48418101423378fbd
        function simulationUpdate() {

            context.save();

            context.clearRect(0, 0, graphWidth, height);
            context.translate(transform.x, transform.y);
            context.scale(transform.k, transform.k);

            // draw heatmap
            if (mergedHeatmapIsActive() || normalHeatmapIsActive() || churnHeatmapIsActive() || hotspotHeatmapIsActive()) {
                drawHeatMap(context)
            }

            // this is pretty cpu hungry
            drawHulls(context)

            // draw edges
            drawEdges(context)

            // Draw nodes
            drawNodes(context)

            context.restore();
        }

        // draw a single cluster hull as a polygon 
        function drawHull(context, clusterId) {
            let pointArray = getPointArrayForClusterId(clusterId)
            let hullArray = getHullFromPointArray(pointArray)
            let firstNodeInCluster = clusterMap[clusterId][0]
            context.fillStyle = nodeColorByModularity(firstNodeInCluster, 0.2)

            context.beginPath();

            let firstPoint = hullArray[0]
            context.moveTo(firstPoint[0], firstPoint[1]);

            hullArray.forEach(function(arrayElement, i) {
                context.lineTo(arrayElement[0], arrayElement[1]);
            })

            context.closePath();
            context.fill();
        }

        // draw all required cluster hulls (selected/hovered nodes from the menu)
        function drawHulls(context) {

            // draw a hull if someone hovers ofer a hull menu cluster node 
            if (hoveredClusterHullId !== undefined) {
                drawHull(context, hoveredClusterHullId)
            }

            // draw every hull was was selected by a mouse click before 
            selectedClusterHullIds.forEach(clusterId => {
                drawHull(context, clusterId)
            })
        }

        /**
         * * MARK: - Handling of data structures
         */
        function prepareGraphStructures() {
            if (typeof file_result_dependency_graph !== 'undefined') {
                graphData['file_result_dependency_graph'] = {}
                graphData['file_result_dependency_graph']['graph'] = file_result_dependency_graph
                graphData['file_result_dependency_graph']['statistics'] = file_result_dependency_graph_statistics
                graphData['file_result_dependency_graph']['overall_metric_results'] =
                    file_result_dependency_graph_overall_metric_results
                graphData['file_result_dependency_graph']['cluster_metrics_map'] = file_result_dependency_graph_cluster_metrics_map
                currentGraphType = 'file_result_dependency_graph'
            }

            if (typeof entity_result_dependency_graph !== 'undefined') {
                graphData['entity_result_dependency_graph'] = {}
                graphData['entity_result_dependency_graph']['graph'] = entity_result_dependency_graph
                graphData['entity_result_dependency_graph']['statistics'] = entity_result_dependency_graph_statistics
                graphData['entity_result_dependency_graph']['overall_metric_results'] =
                    entity_result_dependency_graph_overall_metric_results
                graphData['entity_result_dependency_graph']['cluster_metrics_map'] = entity_result_dependency_graph_cluster_metrics_map
                currentGraphType = 'entity_result_dependency_graph'
            }

            if (typeof entity_result_inheritance_graph !== 'undefined') {
                graphData['entity_result_inheritance_graph'] = {}
                graphData['entity_result_inheritance_graph']['graph'] = entity_result_inheritance_graph
                graphData['entity_result_inheritance_graph']['statistics'] = entity_result_inheritance_graph_statistics
                graphData['entity_result_inheritance_graph']['overall_metric_results'] =
                    entity_result_inheritance_graph_overall_metric_results
                graphData['entity_result_inheritance_graph']['cluster_metrics_map'] = entity_result_inheritance_graph_cluster_metrics_map
            }

            if (typeof entity_result_complete_graph !== 'undefined') {
                graphData['entity_result_complete_graph'] = {}
                graphData['entity_result_complete_graph']['graph'] = entity_result_complete_graph
                graphData['entity_result_complete_graph']['statistics'] = entity_result_complete_graph_statistics
                graphData['entity_result_complete_graph']['overall_metric_results'] =
                    entity_result_complete_graph_overall_metric_results
                graphData['entity_result_complete_graph']['cluster_metrics_map'] = entity_result_complete_graph_cluster_metrics_map
            }

            if (typeof filesystem_graph !== 'undefined') {
                graphData['filesystem_graph'] = {}
                graphData['filesystem_graph']['graph'] = filesystem_graph
                graphData['filesystem_graph']['statistics'] = filesystem_graph_statistics
                graphData['filesystem_graph']['overall_metric_results'] = filesystem_graph_overall_metric_results
                graphData['filesystem_graph']['cluster_metrics_map'] = filesystem_graph_cluster_metrics_map
            }
        }

        function resetSimulationData() {
            if (simulation !== undefined) {
                simulation.stop()
            }

            metricKeys = nodesData = linksData = []
            simulation = undefined
        }

        // based on https://bocoup.com/blog/smoothly-animate-thousands-of-points-with-html5-canvas-and-d3 / Peter Beshai
        // basically animates the increase/decrease of the node radius based on chosen metrics
        function animateRadiusWithMetric(metricName) {

            let addedMetric = true
            if (activeMetrics.includes(metricName)) {
                removeItemAll(activeMetrics, metricName)
                addedMetric = false
            } else {
                activeMetrics.push(metricName)
                addedMetric = true
            }

            // console.log(metricName)
            const duration = 250;
            const ease = d3.easeCubic;

            timer = d3.timer((elapsed) => {
                // compute how far through the animation we are (0 to 1)
                const t = Math.min(1, ease(elapsed / duration));

                // update point positions (interpolate between source and target)
                currentGraph.nodes.forEach(node => {
                    if (metricName in node.metrics) {
                        // this resets all nodes back to the default radius
                        let newRadius = 0

                        // now interpolate for every x between f(0) and f(1): f(x) = f(0) * (1-x) + f(1) * x
                        if (addedMetric) {                            
                            newRadius = node.radius * (1 - t) + (node.radius + (node.metrics[metricName] * analysis_config['metrics']['radius_multiplication'][metricName] )) * t;
                            
                            if (newRadius > node.radius) {
                                node.radius = newRadius
                            }

                        } else {
                            newRadius = node.radius * (1 - t) + (node.radius - (node.metrics[metricName] * analysis_config['metrics']['radius_multiplication'][metricName] )) * t;
                            if (newRadius > radius) {
                                node.radius = newRadius
                            } else {
                                node.radius = radius
                            }
                        }
                    }
                });

                // if this animation is over
                if (t === 1) {
                    // always make sure that node sizes return to default if no metric is active
                    if (activeMetrics.length == 0) {
                        currentGraph.nodes.forEach(node => {
                            node.radius = radius
                        })
                    }

                    // stop this timer since we are done animating.
                    timer.stop();
                }

                // update what is drawn on screen
                simulationUpdate();
            });
        }

        /**
         * * MARK: - Create/update the HTML/Bootstrap UI
         */

        function cancelNodeSearch() {
            $('#inputNodeSearch').val('')
            $('#inputNodeSearchLabel').text('Search inactive')
            searchString = ""

            searchTerms = []

            isSearching = false
            simulationUpdate()
        }

        // setup keyboard shortcut keys for node selection
        // shift + 's' key: select/unselect node
        // shift + 'e' key: expand selected nodes level deeper
        // shift + 'h' key: expand hovered nodes level deeper
        // shift + 'r' key: reset current selection
        // shift + 'f' key: fade unselected nodes
        function enableNodeSelection() {
            let keySelectUnselect = 'S'
            let keyExpandSelection = 'E'
            let keyExpandHoveredNode = 'H'
            let keyResetCurrentSelection = 'R'
            let keyFadeUnselectedNodes = 'F'

            d3.select('body')
                .on("keydown", function(event) { 

                    if (event.key == keySelectUnselect) {
                        if (closeNode != null) {
                            if (closeNode.id.toLowerCase() in selectedNodesMap) {
                                delete selectedNodesMap[closeNode.id.toLowerCase()]
                            } else {
                                selectedNodesMap[closeNode.id.toLowerCase()] = true
                            }
                            simulationUpdate()
                        }
                    }

                    if (event.key == keyExpandSelection) {
                        if (selectedNodesMap.length != 0) {
                            let newSelectedNodesMap = {...selectedNodesMap}
                            currentGraph.links.forEach(function(d) {
                                if (d.source.id.toLowerCase() in selectedNodesMap || d.target.id.toLowerCase() in selectedNodesMap) {
                                    newSelectedNodesMap[d.source.id.toLowerCase()] = true
                                    newSelectedNodesMap[d.target.id.toLowerCase()] = true
                                }
                            })
                            selectedNodesMap = newSelectedNodesMap
                            simulationUpdate()
                        }
                    }

                    if (event.key == keyExpandHoveredNode) {
                        if (closeNode != null) {
                            selectedNodesMap[closeNode.id.toLowerCase()] = true
                            let newSelectedNodesMap = {...selectedNodesMap}
                            currentGraph.links.forEach(function(d) {
                                if (d.source.id == closeNode.id || d.target.id == closeNode.id) {
                                    newSelectedNodesMap[d.source.id.toLowerCase()] = true
                                    newSelectedNodesMap[d.target.id.toLowerCase()] = true
                                }
                            })
                            selectedNodesMap = newSelectedNodesMap
                            simulationUpdate()
                        }
                    }

                    if (event.key == keyResetCurrentSelection) {
                        selectedNodesMap = {}
                        simulationUpdate()
                    }

                    if (event.key == keyFadeUnselectedNodes) {
                        fadeUnselectedNodes = !fadeUnselectedNodes
                        if (fadeUnselectedNodes == true) {
                            $("#li-unselected-opacity").removeClass('d-none');
                            $("#unselected-opacity").removeClass('d-none');
                            $('#fadeUnselectedNodesLabelText').html('<b>f fading unselected nodes</b>')
                            
                        } else {
                            $("#li-unselected-opacity").addClass('d-none');
                            $("#unselected-opacity").addClass('d-none');
                            $('#fadeUnselectedNodesLabelText').html('<b>f</b> fade unselected nodes')
                        }
                        simulationUpdate()
                    }
            });
        }

        function enableSearchInput() {
            $('#inputNodeSearchLabel').text('Search inactive')
            $('#inputNodeSearch').on('keyup change', function() {
                searchString = $(this).val().toLowerCase()

                searchTerms = searchString.split(" ")
                searchTerms = searchTerms.filter(Boolean);
                // console.log(searchTerms)
                 
                searchResults = 0
                if (searchString.length > 0 && searchTerms.length > 0) {
                    isSearching = true
                    simulationUpdate()
                    $('#inputNodeSearchLabel').text(searchResults + ' nodes found')

                } else {
                    isSearching = false
                    simulationUpdate()
                    $('#inputNodeSearchLabel').text('Search inactive')
                }
            })

            $('#inputNodeSearchCancel').on('click', function() {
                cancelNodeSearch()
            })
        }

        function addToolTipsToMetricEntries() {
            $('#badge_metric_sloc_in_file').attr('data-bs-toggle', 'tooltip')
            $('#badge_metric_sloc_in_file').attr('data-bs-title', description_metric_sloc_in_file)
            $('#badge_metric_sloc_in_file').attr('data-bs-html', 'true')
            $('#badge_metric_sloc_in_file').attr('data-bs-placement', 'bottom')

            $('#badge_metric_sloc_in_entity').attr('data-bs-toggle', 'tooltip')
            $('#badge_metric_sloc_in_entity').attr('data-bs-title', description_metric_sloc_in_file)
            $('#badge_metric_sloc_in_entity').attr('data-bs-html', 'true')
            $('#badge_metric_sloc_in_entity').attr('data-bs-placement', 'bottom')

            $('#badge_metric_number_of_methods_in_file').attr('data-bs-toggle', 'tooltip')
            $('#badge_metric_number_of_methods_in_file').attr('data-bs-title', description_metric_number_of_methods)
            $('#badge_metric_number_of_methods_in_file').attr('data-bs-html', 'true')
            $('#badge_metric_number_of_methods_in_file').attr('data-bs-placement', 'bottom')

            $('#badge_metric_number_of_methods_in_entity').attr('data-bs-toggle', 'tooltip')
            $('#badge_metric_number_of_methods_in_entity').attr('data-bs-title', description_metric_number_of_methods)
            $('#badge_metric_number_of_methods_in_entity').attr('data-bs-html', 'true')
            $('#badge_metric_number_of_methods_in_entity').attr('data-bs-placement', 'bottom')

            // TODO
            $('#badge_metric_fan_in_dependency_graph').attr('title', description_metric_fan_in)
            // $('#badge_metric_fan_in_dependency_graph').tooltip();
            $('#badge_metric_fan_in_complete_graph').attr('title', description_metric_fan_in)
            // $('#badge_metric_fan_in_complete_graph').tooltip();
            $('#badge_metric_fan_in_inheritance_graph').attr('title', description_metric_fan_in)
            // $('#badge_metric_fan_in_inheritance_graph').tooltip();

            $('#badge_metric_fan_out_dependency_graph').attr('title', description_metric_fan_out)
            // $('#badge_metric_fan_out_dependency_graph').tooltip();
            $('#badge_metric_fan_out_complete_graph').attr('title', description_metric_fan_out)
            // $('#badge_metric_fan_out_complete_graph').tooltip();
            $('#badge_metric_fan_out_inheritance_graph').attr('title', description_metric_fan_out)
            // $('#badge_metric_fan_out_inheritance_graph').tooltip();

            $('#badge_metric_file_result_dependency_graph_louvain_modularity_file').attr('title', description_metric_louvain_modularity)
            // $('#badge_metric_file_result_dependency_graph_louvain_modularity_file').tooltip();

            $('#badge_metric_entity_result_dependency_graph_louvain_modularity_in_entity').attr('title', description_metric_louvain_modularity)
            // $('#badge_metric_entity_result_dependency_graph_louvain_modularity_in_entity').tooltip();

            $('#badge_metric_entity_result_inheritance_graph_louvain_modularity_in_entity').attr('title', description_metric_louvain_modularity)
            // $('#badge_metric_entity_result_inheritance_graph_louvain_modularity_in_entity').tooltip();

            $('#badge_metric_entity_result_complete_graph_louvain_modularity_in_entity').attr('title', description_metric_louvain_modularity)
            // $('#badge_metric_entity_result_complete_graph_louvain_modularity_in_entity').tooltip();

            $('#badge_metric_entity_result_complete_graph_louvain_modularity_in_entity').attr('title', description_metric_louvain_modularity)
            // $('#badge_metric_entity_result_complete_graph_louvain_modularity_in_entity').tooltip();

            const tooltipTriggerList = document.querySelectorAll('[data-bs-toggle="tooltip"]')
            const tooltipList = [...tooltipTriggerList].map(tooltipTriggerEl => new bootstrap.Tooltip(tooltipTriggerEl))
        }

        function addToolTipsToHeatMap() {
            const badgeHeatmapNormalTooltip = new bootstrap.Tooltip(document.getElementById('badge_heat_map_normal'), {});
            badgeHeatmapNormalTooltip._config.title = description_heat_map_normal

            const badgeHeatmapHybridTooltip = new bootstrap.Tooltip(document.getElementById('badge_heat_map_hybrid'), {});
            badgeHeatmapHybridTooltip._config.title = description_heat_map_hybrid
        }

        function addToolTipToShortcuts() {
            const badgeShortcutsTooltip = new bootstrap.Tooltip(document.getElementById('badge_shortcuts'), {});
            badgeShortcutsTooltip._config.template = wide_tooltip_template
            badgeShortcutsTooltip._config.title = description_shortcuts_tooltip
        }

        function addTooltipUnselectedOpacity() {
            const badgeUnselectedOpacityTooltip = new bootstrap.Tooltip(document.getElementById('badge_unselected_opacity'), {});
            badgeUnselectedOpacityTooltip._config.title = description_unselected_opacity
        }

        function addTooltipSemanticSearch() {
            const badgeSemanticSearchTooltip = new bootstrap.Tooltip(document.getElementById('badge_semantic_search'), {});
            badgeSemanticSearchTooltip._config.title = description_semantic_search
        }

        function addTooltipClusterHulls() {
            const badgeBadgeClusterHullsTooltip = new bootstrap.Tooltip(document.getElementById('badge_cluster_hulls'), {});
            badgeBadgeClusterHullsTooltip._config.title = description_cluster_hulls
        }

        function addTooltipProjectInfo() {
            let configProjectName = analysis_config['project_name']
            let analysisName = getAnalysisName()
            let configAnalysisDateTime = analysis_config['analysis_date']

            description_project_info = "<strong>Project:</strong> " + configProjectName + "<br>" + "<strong>Analysis:</strong> " + analysisName + "<br>" + "<strong>Date:</strong> " + configAnalysisDateTime          
            const badgeProjectInfoTooltip = new bootstrap.Tooltip(document.getElementById('badge_project_info'), {});
            badgeProjectInfoTooltip._config.title = description_project_info
        }
        
        function addTooltipGraphInfo() {
            description_graph_info = "<strong>Graph nodes:</strong> " + currentGraph.nodes.length + "<br>" + "<strong>Graph edges:</strong> " + currentGraph.links.length + "<br>" + "<strong>Charge force:</strong> " + currentChargeForce
            const badgeGraphInfoTooltip = new bootstrap.Tooltip(document.getElementById('badge_graph_info'), {});
            badgeGraphInfoTooltip._config.title = description_graph_info
        }

        function createStatistics() {
            // create statistics table
            statistics_html = ""
            for (let key in statistics) {
                if (statistics.hasOwnProperty(key)) {
                    statistics_html += "<tr>"

                    statistics_html += "<td>"
                    statistics_html += key
                    statistics_html += "</td>"

                    statistics_html += "<td>"
                    statistics_html += statistics[key]
                    statistics_html += "</td>"

                    statistics_html += "</tr>"
                }
            }
            d3.select("#tbody-statistics").html(statistics_html)
        }

        function createOverallMetricResults() {
            // create metrics table
            metrics_html = ""
            for (let key in overall_metric_results) {
                if (overall_metric_results.hasOwnProperty(key)) {
                    metrics_html += "<tr>"

                    metrics_html += "<td>"
                    metrics_html += key
                    metrics_html += "</td>"

                    metrics_html += "<td>"

                    let valueString = String(overall_metric_results[key])
                    if (valueString.length > 30) {
                        valueString = valueString.substring(0, 32) + '...';
                    }

                    metrics_html += String(valueString)
                    metrics_html += "</td>"

                    metrics_html += "</tr>"
                }
            }
            d3.select("#tbody-metrics").html(metrics_html)
        }

        function createMetricsMenuEntries() {
            // create apply metrics menu entries
            applyMetricHtml = ""

            for (let key in currentMetricKeys) {
                applyMetricHtml += '<li> &nbsp; <input data-value="'
                applyMetricHtml += currentMetricKeys[key]
                applyMetricHtml += '" type="checkbox" onclick="animateRadiusWithMetric(\''
                applyMetricHtml += currentMetricKeys[key]
                applyMetricHtml += '\');"/>&nbsp; <span id="'
                applyMetricHtml += '" style="font-size:10px;">'

                let visibleMetricName = currentMetricKeys[key].replace(/_/gi, " ").replace(/metric/gi, "")
                
                // reformat the visible metric name if necessary
                if (visibleMetricName.includes('louvain modularity')) { visibleMetricName = 'louvain modularity' }
                
                applyMetricHtml += visibleMetricName
                applyMetricHtml += '</span> <small><span id="'
                applyMetricHtml += 'badge_' + currentMetricKeys[key]
                applyMetricHtml += '" data-bs-toggle="tooltip" data-bs-placement="bottom" title="" class="badge badge-primary badge-pill text-bg-primary"> ?</span> </small> &nbsp;</li>'
            }

            d3.select("#dropdown-apply-metric").html(applyMetricHtml)
        }

        function getAnalysisName() {
            let analysisName = analysis_config['analysis_name']
            if (analysisName.length > 24) {
                analysisName = analysisName.slice(0, 24) + '...'
            }
            return analysisName
        }

        function addGraphTypeSelectionToMenu() {
            graphSelectHtml = ""
            for (let key in graphData) {
                graphSelectHtml += '<button class="dropdown-item btn-sm" style="font-size: 10px;" type="button" onclick="startWithGraph(\''
                graphSelectHtml += key
                graphSelectHtml += '\');">'
                graphSelectHtml += key.replace(/_/gi, " ")
                graphSelectHtml += "</button>"
            }

            d3.select("#dropdown-graph").html(graphSelectHtml)
            d3.select("#selectedGraph").text(currentGraphType.replace(/_/gi, " ").slice(0, 20) + '...')
        }

        function increaseCurrentChargeForce() {
            if (currentChargeForce < -50) {
                currentChargeForce += 50
                d3.select("#chargeForce").text(currentChargeForce)
                simulation.force("charge", d3.forceManyBody().strength(currentChargeForce))
                simulation.alpha(1).restart();
            }
        }

        function decreaseCurrentChargeForce() {
            currentChargeForce -= 50
            d3.select("#chargeForce").text(currentChargeForce)
            simulation.force("charge", d3.forceManyBody().strength(currentChargeForce))
            simulation.alpha(1).restart();
        }

        /**
         * * MARK: - heatmap
         */

        function normalHeatmapIsActive() { return heatmapActive }
        function mergedHeatmapIsActive() { return heatmapMerged }
        function churnHeatmapIsActive() { return heatmapChurn }
        function hotspotHeatmapIsActive() { return heatmapHotspot }

        function initSemanticSearchSwitch() {
            $("#switchAddSemanticSearch").on('change', function() {
                addSemanticSearch = $(this).is(':checked');
                searchResults = 0
                simulationUpdate();
                $('#inputNodeSearchLabel').text(searchResults + ' nodes found')                
            })
        }

        function initAppConfig() {
            $('#configEmergeVersion').text('Emerge ' + analysis_config['emerge_version'])
        }

        function updateAppUI() {
            if (fadeUnselectedNodes == true) {
                $("#li-unselected-opacity").removeClass('d-none');
                $("#unselected-opacity").removeClass('d-none');
            } else {
                $("#li-unselected-opacity").addClass('d-none');
                $("#unselected-opacity").addClass('d-none');
            }

            // currently only show git heatmaps for file dependency graph
            if (currentGraphType.includes('file_result_dependency_graph')) {
                $("#formSwitchChurnHeatmap").removeClass('d-none');
                $("#formSwitchHotspotHeatmap").removeClass('d-none');
            } else {
                $("#formSwitchChurnHeatmap").addClass('d-none');
                $("#formSwitchHotspotHeatmap").addClass('d-none');
            }
        }

        function initAppUI() {
            updateAppUI()
            initGitMetricsForDateRange()
            initDateRangeUI()
        }

        // TODO
        function initTemporalEdges() {

            let temporal_edges = commit_metrics.reduce(function(ids, obj){
                if(obj.links.length !== 0){
                    ids.push(obj.links);
                }
                return ids;
            }, []);

            temporal_edges = temporal_edges.flat()
            // console.log(temporal_edges)

            if (simulation !== undefined) {
                simulation.stop()
            }

            graphData['file_result_dependency_graph']['graph']['links'] = temporal_edges

            currentGraph = JSON.parse(JSON.stringify(graphData['file_result_dependency_graph']['graph']))
            currentGraph.links = temporal_edges  //[...currentGraph.links, ...temporal_edges];

            startWithGraph('file_result_dependency_graph')            

        }

        function toggleTemporalEdges(toggle) {

        } 

        function initAddTemporalSwitch() {
            $("#switchTemporalEdges").on('change', function() {
                if ($(this).is(':checked')) {
                    addTemporalEdges = true
                    initTemporalEdges()
                    showDebugToast('temp edges: ' + addTemporalEdges)
                } else {
                    addTemporalEdges = false
                    showDebugToast('temp edges: ' + addTemporalEdges)
                }

                simulationUpdate();
            })
        }

        function initHeatmapSwitches() {
            // normal heatmap
            $("#switchActivateHeatmap").on('change', function() {
                if ($(this).is(':checked')) {
                    heatmapActive = true
                    if ($("#switchMergeHeatmap").is(':checked')) {
                        $("#switchMergeHeatmap").prop('checked', false);
                        heatmapMerged = false
                    }

                    if ($("#switchChurnHeatmap").is(':checked')) {
                        $("#switchChurnHeatmap").prop('checked', false);
                        heatmapChurn = false
                    }

                    if ($("#switchHotspotHeatmap").is(':checked')) {
                        $("#switchHotspotHeatmap").prop('checked', false);
                        heatmapHotspot = false
                    }
                } else {
                    heatmapActive = false
                }

                simulationUpdate();
            });

            // hybrid/merged heatmap
            $("#switchMergeHeatmap").on('change', function() {
                if ($(this).is(':checked')) {
                    heatmapMerged = true
                    if ($("#switchActivateHeatmap").is(':checked')) {
                        $("#switchActivateHeatmap").prop('checked', false);
                        heatmapActive = false
                    }

                    if ($("#switchChurnHeatmap").is(':checked')) {
                        $("#switchChurnHeatmap").prop('checked', false);
                        heatmapChurn = false
                    }

                    if ($("#switchHotspotHeatmap").is(':checked')) {
                        $("#switchHotspotHeatmap").prop('checked', false);
                        heatmapHotspot = false
                    }
                } else {
                    heatmapMerged = false
                }

                simulationUpdate();
            });

            // churn heatmap
            $("#switchChurnHeatmap").on('change', function() {
                if ($(this).is(':checked')) {
                    heatmapChurn = true
                    if ($("#switchActivateHeatmap").is(':checked')) {
                        $("#switchActivateHeatmap").prop('checked', false);
                        heatmapActive = false
                    }

                    if ($("#switchMergeHeatmap").is(':checked')) {
                        $("#switchMergeHeatmap").prop('checked', false);
                        heatmapMerged = false
                    }

                    if ($("#switchHotspotHeatmap").is(':checked')) {
                        $("#switchHotspotHeatmap").prop('checked', false);
                        heatmapHotspot = false
                    }
                } else {
                    heatmapChurn = false
                }

                simulationUpdate();
            });

            // hotspot heatmap
            $("#switchHotspotHeatmap").on('change', function() {
                if ($(this).is(':checked')) {
                    heatmapHotspot = true
                    if ($("#switchActivateHeatmap").is(':checked')) {
                        $("#switchActivateHeatmap").prop('checked', false);
                        heatmapActive = false
                    }

                    if ($("#switchMergeHeatmap").is(':checked')) {
                        $("#switchMergeHeatmap").prop('checked', false);
                        heatmapMerged = false
                    }

                    if ($("#switchChurnHeatmap").is(':checked')) {
                        $("#switchChurnHeatmap").prop('checked', false);
                        heatmapChurn = false
                    }
                } else {
                    heatmapHotspot = false
                }

                simulationUpdate();
            });

        }

        /**
         * * MARK: - Helper functions
         */

        // borrowed from https://stackoverflow.com/questions/5767325/how-can-i-remove-a-specific-item-from-an-array
        function removeItemAll(arr, value) {
            let i = 0;
            while (i < arr.length) {
                if (arr[i] === value) {
                    arr.splice(i, 1);
                } else {
                    ++i;
                }
            }
            return arr;
        }

        //https://stackoverflow.com/questions/21646738/convert-hex-to-rgba
        function hexToRGB(hex, alpha) {
            let r = parseInt(hex.slice(1, 3), 16),
                g = parseInt(hex.slice(3, 5), 16),
                b = parseInt(hex.slice(5, 7), 16);

            if (alpha) {
                return "rgba(" + r + ", " + g + ", " + b + ", " + alpha + ")";
            } else {
                return "rgb(" + r + ", " + g + ", " + b + ")";
            }
        }


        function generateTimeSeriesChart() {
            // set the dimensions and margins of the graph
            const margin = {top: 10, right: 30, bottom: 30, left: 60},
                width = 460 - margin.left - margin.right,
                height = 400 - margin.top - margin.bottom;

            // append the svg object to the body of the page
            const svg = d3.select("#my_dataviz")
            .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
            .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            //Read the data
            d3.csv("https://raw.githubusercontent.com/holtzy/data_to_viz/master/Example_dataset/3_TwoNumOrdered_comma.csv",

            // When reading the csv, I must format variables:
            function(d){
                return { date : d3.timeParse("%Y-%m-%d")(d.date), value : d.value }
            }).then(

            // Now I can use this dataset:
            function(data) {

                // Add X axis --> it is a date format
                const x = d3.scaleTime()
                .domain(d3.extent(data, function(d) { return d.date; }))
                .range([ 0, width ]);
                svg.append("g")
                .attr("transform", `translate(0, ${height})`)
                .call(d3.axisBottom(x));

                // Add Y axis
                const y = d3.scaleLinear()
                .domain([0, d3.max(data, function(d) { return +d.value; })])
                .range([ height, 0 ]);
                svg.append("g")
                .call(d3.axisLeft(y));

                // Add the line
                svg.append("path")
                .datum(data)
                .attr("fill", "none")
                .attr("stroke", "steelblue")
                .attr("stroke-width", 1.5)
                .attr("d", d3.line()
                    .x(function(d) { return x(d.date) })
                    .y(function(d) { return y(d.value) })
                    )

            })
        }


    </script>

</body>